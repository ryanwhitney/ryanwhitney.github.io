<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
     <title>dotter</title>
    <script src="../neatcommands.js"></script>
    <style>
    
    /* CSS files add styling rules to your content */
    *{
      font-family:  SFMono-Regular, "SFMono-Regular", SFMono, Menlo,
        Monaco, Consolas,"Liberation Mono","Courier New", monospace;
        box-sizing: border-box;
    }
    html{
      overflow-x: hidden;
    }
    body {
      font-family: helvetica, arial, sans-serif;
      margin: 0;
      font-size: 12px;
      background-color: #000;
      transition: background-color .3s ease;
      --textColor: white;
      overflow-x: hidden;
      display: flex;
    }
    
    .draw-color{
      color: var(--currentNewDrawColor)
    }
    
    header{
      
    }
    h1{
      color: var(--currentNewDrawColor);
      text-transform: lowercase;
      text-align: center;
    }
    #dotter-num{
      font-size: 19px;
      font-weight: 100;
      position: relative;
      top: -.5px;
    }
    header button{
      font-size: 19px;
      font-weight: 100;
      position: relative;
      top: -4px;
    }
    p{
      line-height: 1.5;
    }
    #main{
      flex: 1;
    }
    #code-editor-input .comment{
      color: var(--textColor) !important;
      opacity: .8;
      position: relative;
      top: -6px;
    }
    #export-window{
      z-index: 999009;
      width: 80%;
      height: 80%;
      display: none;
      position: fixed;
      flex-direction: column;
      top: 50%;
      left: 50%;
      padding: 20px;
      /* bring your own prefixes */
      transform: translate(-50%, -50%);
      background-color: grey;
    }
    .overlay{
      height: 100%;
      width: 100%;
      position: fixed; /* Stay in place */
      z-index: 99999;
      display: none;
      touch-action: none;
      left: 0;
      top: 0;
      background-color: var(--bgColor);
      filter: brightness(0.2);
      opacity: .4;
    }
    .modal-inner{
      display: flex;
      flex: 1;
      height: 100%;
    }
    .modal-inner > div{
      flex: 1;
    }
    .modal-inner textarea{
      display: flex;
      height: 400px;
      flex: 1;
      width: 80%;
    }
    #pxon-scale{
      position: absolute;
      right: 85px;
      top: 7.5px;
    }
    #copy-pxon{
      position: absolute;
      right: 5px;
      top: 5px;
    }
    #pxon-panel{
      display: flex;
      flex-direction: column;
      line-break: normal;
      float: right;
      width: 40%;
      display: none;
      z-index: 1;
      color: var(--textColor);
      transition: width .2s ease-in-out;
      border-left: 1px solid rgba(255,255,255,.03);
      background: var(--bgColor);
    }
    #pxon-panel .right-panel-text{
      padding: 0 20px 20px;
      margin-top: 50px;
    }
    #pxon-panel a{
      color: var(--currentNewDrawColor);
      font-style: italic;
      position: relative;
      transition: all .2s ease;
      bottom:0;
    }
    #pxon-panel a:hover{
      bottom: 2px;
    }
    #raw{
      overflow: hidden;
      overflow-y: scroll;
      background: none;
      border: none;
      height: 100%;
      color: var(--textColor);
    }
    input,label, button{
      text-transform: lowercase;
      font-size: 13px;
      color: var(--textColor);
    }
    label{
      padding-bottom: 5px;
    }
    input{
      font-size:16px;
    }
    .tools{
      display: flex;
      margin: 5px;
      padding-bottom: 10px;
      justify-content: space-around;
      align-items: flex-end;
      max-width: 500px;
      margin: 0 auto;
      padding: 20px 0 10px;
    }
    .tools label{
      display: block;
      line-height: 1.5;
    }
    .tools.colors div, .tools.sizing div{
      text-align: center;
    }
    #select-draw-erase label{
      display: inline-block;
    }
    #grid-container{
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
       -khtml-user-select: none; /* Konqueror HTML */
         -moz-user-select: none; /* Old versions of Firefox */
          -ms-user-select: none; /* Internet Explorer/Edge */
              user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
      margin-bottom: 10px;
    }
    #grid-container .board{
      margin: auto;
      touch-action: none;
    }
    .board-container{
      display: flex;
      justify-content:space-around;
      align-content: center;
    }
    .board{
      display: grid;
      grid-gap: 3px 3px;
      grid-template-rows: repeat(16, 20px);
      grid-template-columns: repeat(16, 20px);
    }
    .dot{
      background-color: #19181A;
    }  
    input[type=color]{
      /* border: none;
      background-color: transparent; */
    }
    input[type=number]{
      background-color:transparent;
      width: 60px;
    }
    input[type=submit]{
      margin-top: 10px;
      background-color:transparent;
      border-width: 1px;
      border-color: var(--currentNewDrawColor) !important;
      float: right;
      color: var(--textColor);
    }
    #draw-with-words{
      margin: 40px auto 20px;
      width: 364px;
      padding-bottom: 50px;
      color: var(--textColor);
    }
    code{
      width: 364px;
      min-height: 150px;
      border: 1px solid var(--currentNewDrawColor);
      line-height: 1.5;
      border-radius: 6px;
      display: block;
      margin: auto;
      padding: 20px;
      text-align: left;  
      text-transform: unset !important;    
    }
    code div::before{
      content: ">";
      margin-left:-12px;
    }
    code {
      color: var(--currentNewDrawColor) !important;
      text-align: left;      
      text-transform: unset !important;
    }
    span.code{
      color: var(--currentNewDrawColor);
    }    
    button{
      background-color: black;
      border-width: 1px;
      color: var(--textColor);
    }
    #more-tools{
      display: flex;
      flex-direction: column;
      position: fixed;
      bottom: 10px;
      left: 10px;
      z-index: 9999;
    }
    #more-tools input,
    #more-tools label{
      background-color: rgba(0,0,0,.2);
      
    }
    #undo-visualizer * {
      display: inline-block;
    }
    #undo-visualizer #undo-tile-scale, 
    #undo-visualizer #undo-tile-gap{
      display: none;
    }
    #undo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #redo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #undo-history:first-child { margin-top: auto }
    #undo-history{
      display: flex;
      flex-direction: row-reverse;
      justify-content:  flex-end;
      flex-wrap: nowrap;
      white-space: nowrap;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,.2);
      padding: 10px;
      max-width: 95%;
      overflow-x: scroll;
      margin: 30px auto 0;
    }
    #undo-history .board{
      grid-gap: 0 0;
      margin-right: 10px;
      grid-template-rows: repeat(16, 2px);
      grid-template-columns: repeat(16, 2px);
    }
    #undo-history .dot[style]{
      box-shadow: none !important;
    }
    .before-drawing{
      height: auto;
      display: block;
      opacity: 1;
      transition: all .5s ease;
    }
    .after-drawing{
      height: 0;
      display: none;
      opacity: 0;
      transition: all .5s ease;
    }
    
    #hide-checkbox:checked + label {
      transform: scale(2, 3);
      position: relative;
      left: -5px;
      bottom: -5px;
      font-size: 10px;
    }
    #preview #svg-output{
      transform-origin-x: 0;
      transform-origin-y: 0;
    }
    @media only screen and (min-width: 440px) {
      input,label, button{
        text-transform: lowercase;
        font-size:14px;
        color: var(--textColor);
      }

    }
    </style>
  </head>  
  <body>
    <div id="export-window">
      <h2>Export your dots to PXON or SVG</h2>
      <button id="close-export-modal">close this</button>
      <div class="modal-inner">
        <div id="export-pxon">
          <p>Here's your pxon</p>
          <textarea id="export-pxon-textarea"></textarea>
        </div>
        <div id="export-svg">
          <p>Here's your svg</p>
          <textarea id="export-svg-textarea"></textarea>
        </div>
        <div id="preview">
          <p>Here's your preview</p>
          <small>does anyone know a <i>mathematician</i></small>
        </div>
      </div>
    </div>
    <div id="overlay-backdrop" class="overlay"></div>
    <div id="main">
      <header>
        <h1>DOTTER <button id="dotter-up">‚åÉ</button><span id="dotter-num">16</span><button id="dotter-down">‚åÑ</button></h1>
      </header>
      <div id="grid-container" class="board-container"></div>
      <div class="tools colors">
        <div id="initial-dot-color-select">
          <label for="initial-dot-color-selected">Base color</label>
          <input type="color" id="initial-dot-color-selected" name="select-initial-dot-color" value="#1f1f1f" tabIndex="0"/>
        </div>
        <div id="color-select">
          <label for="color-selected">Draw Color</label>
          <input type="color" id="color-selected" name="select-color" value="#FFA57D" tabIndex="0"/>
        </div>
        <div id="background-select">
          <label for="background-color-selected">Background Color</label>
          <input type="color" id="background-color-selected" name="select-background-color" value="#19181A" tabIndex="0"/>
        </div>
      </div>
      <div class="tools sizing">
        <div id="select-dot-size" >
          <label for="dot-size">dot size</label>
          <input type="number" id="dot-size" name="select-dot-size"
             value="20">
        </div>
        <div id="select-dot-radius-amount">
          <label for="dot-radius-amount">dot radius</label>
          <input type="number" id="dot-radius-amount" name="select-dot-radius-amount"
             value="3" >
        </div>
        <div id="select-grid-gap-size">
          <label for="grid-gap-size">grid gap</label>
          <input type="number" id="grid-gap-size" name="select-grid-gap-size"
             value="3" >
        </div>
        <div id="select-glow-amount">
          <label for="glow-amount">glow</label>
          <input type="number" id="glow-amount" name="select-glow-amount"
             value="0">
        </div>
      </div>
      <div class="tools-container">
        <div class="tools modes">
          <div id="select-draw-erase">
            <input type="radio" id="select-draw-radio" name="draw-erase-radio" value="draw" / checked>
            <label for="select-draw-radio">draw</label><br/>
            <input type="radio" id="select-erase-radio" name="draw-erase-radio" value="erase" />
            <label for="select-erase-radio">erase</label>
          </div>
          <div class="undo">
            <button id="undo-button" disabled>undo</button>
          </div>
          <div class="redo">
            <button id="redo-button" disabled>redo</button>
          </div>
          <div>
            <button id="open-save-export-button">save/export</button>
          </div>
        </div>
        <div id="more-tools">
          <div class="check">
            <input type="checkbox" id="hide-checkbox" name="hide">
            <label for="hide-checkbox">minimize</label>
          </div>
          <div class="check experiment">
            <input type="checkbox" id="code-editor-checkbox" name="code-editor-checkbox" checked>
            <label for="code-editor-checkbox">draw with words</label>
          </div>
          <div class="check experiment">
            <input type="checkbox" id="enable-pxon-viewer" name="enable-pxon-viewer">
            <label for="enable-pxon-viewer">PXON viewer</label>
          </div>
          <div id="undo-visualizer" class="check experiment">
            <input type="checkbox" id="enable-undo-visualizer" name="enable-undo-visualizer">
            <label for="enable-undo-visualizer">undo stack visualizer</label>
            <div id="undo-tile-scale">
              <span>(pls disable if slow)</span>
              <label for="select-undo-tile-scale">&nbsp;&nbsp; scale</label>
              <input type="number" id="select-undo-tile-scale" name="select-undo-tile-scale" value="2" style="width:40px;">
            </div>
            <div id="undo-tile-gap">
              <label for="select-undo-tile-gap">&nbsp;&nbsp; gap</label>
              <input type="number" id="select-undo-tile-gap" name="select-undo-tile-gap" value="0" style="width:40px;">
            </div>
          </div>
        </div>
      </div>
      <div id="draw-with-words">
        <p><span style="font-size:12px">‚ö†Ô∏è</span> heads up this is just javascript</p>
        <p>but also with extra functions available, like:</p>
        <p>
          <span class="code">paint(<b>x</b>,<b>y</b>);</span><br/>
          <span class="code">square(<b>x1</b>,<b>y1</b>,<b>x2</b>,<b>y2</b>);</span><br/>
          <span class="code">horizontal(<b>y</b>);</span><br/>
          <span class="code">vertical(<b>x</b>);</span><br/>
        </p>
        <p>just replace <b>x</b> and <b>y</b> with coordinates.</p>
        <p>bonus: all of these take color (string) as an optional parameter.</p>
        <code name="code-editor" id="code-editor-input" contenteditable="true" autocapitalize="off" autocomplete="off" spellcheck="false">
          <span class="comment" contenteditable="true">// try <strong>paint(0,1,"red");</strong> below<br> 
           // or, submit the existing code ‚ú®</span>
          <br/>
          <div>
            for(i=0;i<16;i++){<br/>
              &nbsp;&nbsp;let color = "hsl("+ i*20 +",65%,70%)";<br/>
              &nbsp;&nbsp;horizontal(i, color);<br/>
            };
          </div>
      </code>
      <input id="submit-code-button" type="submit" value="run the code" title="run the code, do it" />
      <button onclick="moreRainbow();codeEditorInput.innerText=moreRainbow;">üåà</button>
      
        <!-- <pre>
paint(x,y,color)
  x = (number) x coordinate
  y = (number) y coordinate
  color = (string) optional. color in hex "#ffffff" format
  
square(x1,y1,x2,y2,color)
  x1 = (number) x coordinate
  y1 = (number) y coordinate
  x2 = (number) x coordinate
  y2 = (number) y coordinate
  color = (string) optional. color in hex "#ffffff" format
        </pre> -->
      </div>
    </div>
    <div id="pxon-panel">
      <div class="pxon-panel-top">
        <div id="pxon-scale">
          <label for="select-pxon-scale">pxon scale:</label>
          <input type="number" id="select-pxon-scale" value="1" style="width:40px;"/>
        </div>
        <div class="right-panel-text">
          <div class="before-drawing">
            <p>first, you must draw.</p>
          </div>
          <div class="after-drawing">
            <p><b class="draw-color">CONGRATS</b></p>
            <p>You've made <a href="http://jennmoney.biz/pxon">PXON</a>.</p>
            <p>The text below is editable. you'll find copy and download buttons above and to the right.</p>
            <p>Adjust the scale of your pxon, if you'd like!</p>
          </div>
        </div>
        <button id="copy-pxon">copy</button>
      </div>
      <textarea id="raw"></textarea>
    </div>
    
    
<script>
function sleep(milliseconds) { 
  let timeStart = new Date().getTime(); 
  while (true) { 
      let elapsedTime = new Date().getTime() - timeStart; 
      if (elapsedTime > milliseconds) { 
          break; 
      } 
  }
}

var gridContainer,
  undoStack = [],
  gridArray = [],
  gridContainer = document.getElementById('grid-container'),
  undoPresses = 0,
  undoCount = 0,
  undoButton = document.getElementById("undo-button"),
  openSaveExportButton = document.getElementById("open-save-export-button"),
  closeExportModal = document.getElementById("close-export-modal"),
  overlayBackdrop = document.getElementById("overlay-backdrop"),
  BOARD_SIZE = 16,
  dotBoard,
  dotCount,
  currentTool,
  hasDrawnSwitch = false,
  pxonScale = 10,
  dot,
  color,
  undoSize,
  currentUndoSpot,
  currentUndoSpotFromIndex,
  UNDO_VISUALIZER = false; 

//////// SET UP OPTIONS + USER INPUTS

var inputInitialDotColor = document.getElementById("initial-dot-color-selected"),
  inputNewDrawColor = document.getElementById("color-selected"),
  inputBackgroundColor = document.getElementById("background-color-selected"),
  inputDotSize = document.getElementById("dot-size"),
  inputDotRadius = document.getElementById("dot-radius-amount"),
  inputGridGapSize = document.getElementById("grid-gap-size"),
  inputGlowRadius = document.getElementById("glow-amount"),
  inputDrawEraseRadio = document.getElementById("draw"),
  inputHideCheckbox = document.getElementById("hide-checkbox"),
  inputPxonViewerCheckbox = document.querySelector("input[name=enable-pxon-viewer]"),
  inputPxonScale = document.getElementById("select-pxon-scale")
  inputCodeEditorCheckbox = document.getElementById("code-editor-checkbox")
  inputUndoVisualizerCheckbox = document.querySelector("input[name=enable-undo-visualizer]"),
  inputUndoVisualizerScaleContainer = document.getElementById("undo-tile-scale"),
  inputUndoVisualizerScale = document.getElementById("select-undo-tile-scale"),
  inputUndoVisualizerGapContainer = document.getElementById("undo-tile-gap"),
  inputUndoVisualizerGap = document.getElementById("select-undo-tile-gap");

function deleteBoard() {
  if (confirm("Are you sure you want to delete this board? It‚Ä¶cannot be undone.")) {
    var board = document.querySelectorAll("#grid-container .board");
    board[0].remove();
    startup();
  } else {
    return false;
  }
}

var initialDotColor,
  newDrawColor,
  backgroundColor,
  dotSize,
  dotRadius,
  gridGapSize,
  glowRadius,
  hideCheckbox,
  pxonViewerCheckbox,
  codeEditorCheckbox,
  undoVisualizerCheckbox,
  undoVisualizerScale,
  undoVisualizerGap;
  
  var defaultOptions = {
    initialDotColor: "#1f1f1f",
    newDrawColor: "#ffa57d",
    backgroundColor: "#19181a",
    dotSize: 20,
    dotRadius: 3,
    gridGapSize: 3,
    glowRadius: 0,
    hideCheckbox: false,
    pxonViewerCheckbox: false,
    pxonScale: 1,
    codeEditorCheckbox: true,
    undoVisualizerCheckbox: false,
    undoVisualizerScale: 2,
    undoVisualizerGap: 0,
    currentTool: "draw"
  }

function getState(){
  initialDotColor = localStorage.getItem("initialDotColor") | inputInitialDotColor.value;
  newDrawColor = inputNewDrawColor.value;
  backgroundColor = localStorage.getItem("backgroundColor") | inputBackgroundColor.value;
  dotSize = inputDotSize.value;
  dotRadius = inputDotRadius.value;
  gridGapSize = inputGridGapSize.value;
  hideCheckbox = inputHideCheckbox.checked;
  glowRadius = inputGlowRadius.value;
  pxonViewerCheckbox = inputPxonViewerCheckbox.checked;
  codeEditorCheckbox = inputCodeEditorCheckbox.checked;
  undoVisualizerCheckbox = inputUndoVisualizerCheckbox.checked;
  undoVisualizerScale = inputUndoVisualizerScale.value;
  undoVisualizerGap = inputUndoVisualizerGap.value;
}


function loadState(){
  if (typeof(Storage) !== "undefined") {
    initialDotColor = localStorage.getItem("initialDotColor");
    newDrawColor = localStorage.getItem("newDrawColor");
    backgroundColor = localStorage.getItem("backgroundColor");
    dotSize = localStorage.getItem("dotSize");
    dotRadius = localStorage.getItem("dotRadius");
    gridGapSize = localStorage.getItem("gridGapSize");
    glowRadius = localStorage.getItem("glowRadius");
    hideCheckbox = localStorage.getItem("hideCheckbox");
    codeEditorCheckbox = localStorage.getItem("codeEditorCheckbox");
    pxonViewerCheckbox = localStorage.getItem("pxonViewerCheckbox");
    undoVisualizerCheckbox = localStorage.getItem("undoVisualizerCheckbox");
    undoVisualizerScale = localStorage.getItem("undoVisualizerScale");
    undoVisualizerGap = localStorage.getItem("undoVisualizerGap");
  } else {
    // no localstorage..
  }
  
}

function applyState(){
  updateInitialDotColor(initialDotColor)
}

function saveState(){
  if (typeof(Storage) !== "undefined") {
    localStorage.setItem("initialDotColor", initialDotColor);
    localStorage.setItem("newDrawColor", newDrawColor);
    localStorage.setItem("backgroundColor", backgroundColor);
    localStorage.setItem("dotSize", dotSize);
    localStorage.setItem("dotRadius", dotRadius);
    localStorage.setItem("gridGapSize", gridGapSize);
    localStorage.setItem("glowRadius", glowRadius);
    localStorage.setItem("hideCheckbox", hideCheckbox);
    localStorage.setItem("codeEditorCheckbox", codeEditorCheckbox);
    localStorage.setItem("pxonViewerCheckbox", pxonViewerCheckbox);
    localStorage.setItem("undoVisualizerCheckbox", undoVisualizerCheckbox);
    localStorage.setItem("undoVisualizerScale", undoVisualizerScale);
    localStorage.setItem("undoVisualizerGap", undoVisualizerGap);  
  } else {
    // no localstorage..
  }
  
}

// hex to hsl copyright uhhh stack overflow
function unhex(hex){
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  r = parseInt(result[1], 16);
  g = parseInt(result[2], 16);
  b = parseInt(result[3], 16);
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if(max == min){
    h = s = 0; // achromatic
  }else{
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch(max){
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  var HSL = new Object();
  HSL['h']=h;
  HSL['s']=s;
  HSL['l']=l;
  return HSL;
}

// Bind to input changes on INITIAL dot color  
inputInitialDotColor.addEventListener("input", function() {
  updateInitialDotColor(inputInitialDotColor.value);
}, false); 
   
// Bind to input changes on NEW DRAW color  
inputNewDrawColor.addEventListener("input", function() {
  updateNewDrawColor(inputNewDrawColor.value);
}, false); 
      
// Bind to input changes on BACKGROUND color 
inputBackgroundColor.addEventListener("input", function() {
  updateBackgroundColor(inputBackgroundColor.value);
}, false); 

// Bind to input changes on DOT RADIUS
inputDotRadius.addEventListener("input", function() {
  updateDotRadius(inputDotRadius.value);
}, false); 

function updateDotRadius(amount){
  if(!amount){
    amount = 3;
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        border-radius:` + inputDotRadius.value + `px;
    }`;     
  document.head.appendChild(style);
  // update variable
  dotRadius = amount;
  // update input value
  inputDotRadius.value = amount;
  // save state
  saveState();
}

// Bind to input changes on DOT SIZE
inputDotSize.addEventListener("input", function() {
  updateDotScale(inputDotSize.value);
}, false); 

// Handle changes to DOT SIZE
function updateDotScale(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 20;
  }
  var n = sizeInPx + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #grid-container .board{
      grid-template-rows: repeat(` + BOARD_SIZE + `, ` + n + `);
      grid-template-columns: repeat(` + BOARD_SIZE + `, ` + n + `);
    } `;   
  document.head.appendChild(style);
  // update variable
  dotSize = sizeInPx;
  // update input value
  inputDotSize.value = sizeInPx;
  // save state
  saveState();
}

// Bind to input changes on GRID GAP 
inputGridGapSize.addEventListener("input", function() {
  updateGridGapSize(inputGridGapSize.value);
}, false);

function updateGridGapSize(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 3;
  }
  const style = document.createElement('style');
  if (sizeInPx > 0){
    style.innerHTML = `
      #grid-container .board {
          grid-gap: `  + sizeInPx + `px `  + sizeInPx + `px;
      }`;     
  }else{
    style.innerHTML = `
    #grid-container .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateDotScale(dotSize - 1);
  setTimeout(function(){ 
    updateDotScale(dotSize + 1); 
  }, 15);
  // update variable
  gridGapSize = amount;
  // update input value
  inputGridGapSize.value = amount;
  // save state
  saveState();
}

// Bind and handle input changes on GLOW AMOUNT
inputGlowRadius.addEventListener("input", function() {
  updateGlowRadius(inputGlowRadius.value);
}, false); 

// Handle changes to GLOW AMOUNT
function updateGlowRadius(amount){
  if(!amount){
    amount = 0;
  }
  var dots = document.querySelectorAll(".dot");
  dots.forEach(item => 
    item.style.cssText += `box-shadow: 0 0 ` + amount + `px  var(--glowColor),
         0 0 ` + amount + `px  var(--glowColor);`
  );
  // update variable
  glowRadius = amount;
  // update input value
  inputGlowRadius.value = amount;
  // save state
  saveState();
}

// Bind to changes on DRAW / ERASE RADIO
var drawEraseRadios = document.querySelectorAll('input[name=draw-erase-radio]');
if(drawEraseRadios.length) {
  for(count = 0; count < drawEraseRadios.length; count++){
    drawEraseRadios[count].addEventListener('change', function() {
        currentTool = this.value;
    });
  }
}

// Bind to clicks on save/export button
openSaveExportButton.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

closeExportModal.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

overlayBackdrop.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

function toggleExportWindow(){
  var exportWindow = document.getElementById("export-window");
  if (exportWindow.style.display != "block"){
    updatePXON();
    renderSVGfromExportWindow();
    exportWindow.style.display = "block";
    overlayBackdrop.style.display = "flex";
  } else {
    exportWindow.style.display = "none"
    overlayBackdrop.style.display = "none"

  }
}

// Bind & handle changes on PXON VIEWER CHECKBOX
inputPxonViewerCheckbox.addEventListener( 
  'change',
  function() {
    updatePxonViewerCheckbox(this);
  }
);

var dotterNumButtons = document.querySelectorAll("header button");

dotterNumButtons[0].addEventListener('click',function(){
  BOARD_SIZE++;
  document.getElementById('dotter-num').innerHTML = BOARD_SIZE;
  startup();
})
dotterNumButtons[1].addEventListener('click',function(){
  BOARD_SIZE--;
  document.getElementById('dotter-num').innerHTML = BOARD_SIZE;
  startup();
})

// Bind & handle changes on PXON VIEWER CHECKBOX
inputPxonScale.addEventListener( 
  'change',
  function() {
    updatePxonScale(inputPxonScale.value);
  }
);

function updatePxonScale(number){
  pxonScale = number;
  console.log(pxonScale);
  updatePXON();
}


function updatePxonViewerCheckbox(input){
  pxonContainer = document.getElementById("pxon-panel");
  if(input){
    if(input.checked) {
      pxonContainer.style.display = "flex";
      pxonContainer.style.width = "40%";
      inputPxonViewerCheckbox.checked = input.checked;
    } else {
      pxonContainer.style.display = "none";
      pxonContainer.style.width = "0";
      inputPxonViewerCheckbox.checked = input.checked;
    }
  }else{
    pxonContainer.style.display = "none";
    pxonContainer.style.width = "0";
    inputPxonViewerCheckbox.checked = false;
  }  
}

// Set up copy pxon button
copyPxonButton = document.getElementById("copy-pxon");

copyPxonButton.addEventListener("click", function(){
  pxonOutputPre = document.getElementById("raw");
  var copiedPxon = pxonOutputPre;
  copiedPxon.focus();
  copiedPxon.select();
  try {
    let successful = document.execCommand('copy');
    let msg = successful ? 'successful' : 'unsuccessful';
    copyPxonButton.innerText = "successfully copied!";
    setTimeout(function(){
      copyPxonButton.innerText = "copy again";
    }, 1500);
  } catch(err) {
    alert('failed to copy. ‚òπÔ∏è ‚Ä¶ ' + err);
  }

})

// Bind & handle changes on PXON VIEWER CHECKBOX
inputHideCheckbox.addEventListener( 
  'change',
  function() {
    var otherCheckBoxes = document.querySelectorAll("#more-tools .experiment");
    if(this.checked) {
      otherCheckBoxes.forEach(element =>
        element.style.display = "none"
      );
    } else {
      otherCheckBoxes.forEach(element =>
        element.style.display = "block"
      );
    }
      
      
  }
);

var codeEditorInput = document.getElementById("code-editor-input");

// Bind & handle changes on PXON VIEWER CHECKBOX
inputCodeEditorCheckbox.addEventListener( 
  'change',
  function() {
      codeEditor = document.getElementById("draw-with-words");
    if(this.checked) {
      codeEditor.style.display = "block"
    } else {
      codeEditor.style.display = "none"
    }
  }
);

// Bind & handle changes on UNDO VISUALIZER CHECKBOX
inputUndoVisualizerCheckbox.addEventListener( 
  'change', 
  function() {
    if(this.checked) {
        UNDO_VISUALIZER = true;
        var undoVisualizer = document.createElement("div");
        undoVisualizer.id = "undo-history";
        gridContainer.after(undoVisualizer);
        undoVisualizer.innerHTML = "";
        undoStack.forEach(element =>
          undoVisualizer.innerHTML += element
        );
        inputUndoVisualizerScaleContainer.style.display = "inline-block";
        inputUndoVisualizerGapContainer.style.display = "inline-block";
    } else {
      UNDO_VISUALIZER = false;
      var undoVisualizer = document.getElementById('undo-history');
      undoVisualizer.remove();
      inputUndoVisualizerScaleContainer.style.display = "none";
      inputUndoVisualizerGapContainer.style.display = "none";
    }
  }
);

// Bind  to changes on UNDO VISUALIZER SCALE
inputUndoVisualizerScale.addEventListener("input", function() {
  updateUndoVisualizerScale(inputUndoVisualizerScale.value);
}, false); 

// Handle changes to UNDO VISUALIZER SCALE
function updateUndoVisualizerScale(n){
  var n = n + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #undo-history .board{
      grid-template-rows: repeat(` + BOARD_SIZE + `, ` + n + `);
      grid-template-columns: repeat(` + BOARD_SIZE + `, ` + n + `);
    } `;   
  document.head.appendChild(style);
}

// Handle changes to UNDO VISUALIZER SCALE
inputUndoVisualizerGap.addEventListener("input", function() {
  const style = document.createElement('style');
  if (inputUndoVisualizerGap.value > 0){
    style.innerHTML = `
      #undo-history .board {
          grid-gap: `  + inputUndoVisualizerGap.value + `px `  + inputUndoVisualizerGap.value + `px;
      }`;     
  }else{
    style.innerHTML = `
    #undo-history .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateUndoVisualizerScale(inputUndoVisualizerScale.value - 1);
  setTimeout(function(){ 
    updateUndoVisualizerScale(inputUndoVisualizerScale.value); 
  }, 15);
}, false); 


// Handle code input

var inputCodeSubmitButton = document.getElementById("submit-code-button");
inputCodeSubmitButton.addEventListener("click", function(){
  code = document.getElementsByTagName("code");
  userCode = code[0].textContent;
  eval(userCode);
});
      
//////// HANDLING UPDATES

function updateInitialDotColor(color){
  if(!color){
    color = inputInitialDotColor.value
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        --dotColor: ` + color + `;
        background-color: var(--dotColor); 
    }`;     
  // set the value
  initialDotColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (in case changed elsewhere)
  inputInitialDotColor.value = color;  
  // save state
  saveState();
  return color
}

function updateNewDrawColor(color){
  if(!color){
    color = inputNewDrawColor.value;
  }
  document.body.style.setProperty("--currentNewDrawColor", color);
  //set the value
  newDrawColor = color;
  // set the input (in case changed elsewhere)
  inputNewDrawColor.value = color;  
  // save state
  saveState();
  return color
}

function updateBackgroundColor(color){
  if(!color){
    color = inputBackgroundColor.value;
  }
  var hex = unhex(color);
  var foregroundTextColor = "#ffffff";
  if(hex.l > 0.75){
    foregroundTextColor = "#000000";
  } else{
    foregroundTextColor = "#ffffff";
  }
  
  const style = document.createElement('style');
  style.innerHTML = `
    body {
        --bgColor: ` + color + `;
        background-color: var(--bgColor);
        --textColor: ` + foregroundTextColor +`;
        color: ` + foregroundTextColor +`;
    }`;     
  // set the value
  backgroundColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (redundant if changed via input)
  inputBackgroundColor.value = color;
  // save state
  saveState();
  return color;
}      
      
//////// START UP   
function startup() {
  if (gridContainer){
    gridContainer.innerHTML = "";
  }
  // loadState();
  updateInitialDotColor(initialDotColor);
  updateBackgroundColor(backgroundColor);
  updateNewDrawColor(newDrawColor);
  updatePxonViewerCheckbox(pxonViewerCheckbox);

  // CREATE BOARD
  gridContainer = document.getElementById('grid-container');
  dotBoard = document.createElement("div");
  dotBoard.className = "board board0";
  dotBoard.tabIndex = "0";
  gridContainer.appendChild(dotBoard);        
  dotCount = BOARD_SIZE * BOARD_SIZE
  for (iteration = 0; iteration<dotCount; iteration++) {
    dot = dot+iteration;
    dot = document.createElement("div");
    dot.className = "dot";
    dotBoard.appendChild(dot);
  }
    
  updateDotScale(dotSize);
  updateDotRadius(dotRadius);
  updateGlowRadius(glowRadius);
  
  // ADD INITIAL STATE TO UNDO STACK
  grid = document.getElementById('grid-container');
  var gridContent = grid.innerHTML;        
  undoStack.push(gridContent);
  
  bindClicksForCurrentBoard();
  
  // Save grid
  getCurrentPixels();
  saveState();

};


if(document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
  console.log("waiting‚Ä¶");
  callback(); 
} else {
  console.log("art time");
  document.addEventListener("DOMContentLoaded", startup());
}

// event listener for keyup
function checkTabPress(e) {
    "use strict";
    // pick passed event or global event object if passed one is empty
    e = e || event;
    var activeElement;
    if (e.keyCode == 9) {
        // Here read the active selected link.
        activeElement = document.activeElement;
        // If HTML element is an anchor <a>
        console.log(activeElement);
        if (activeElement = document.querySelector('#grid-container .board'))
            // get it's hyperlink
            console.log("it's "+ activeElement);
    }
}




var keyboardLeft = 37,
keyboardUp = 38,
keyboardRight = 39,
keyboardDown = 40,
keyboardTab = 9,
keyboardSpace = 32,
keyboardEnter = 13,
keyboardE = 69, // erase
keyboardD = 68, // draw
keyboardH = 72, // horizontal
keyboardV = 86; // vertical
 

var activeDot;
var dots = document.querySelectorAll('#grid-container .dot');

// Keyboard input handling

// KEY DOWN
document.body.onkeydown = function(e){
  
  var dots = document.querySelectorAll('#grid-container .dot');
  var boardFocused = isFocused(document.querySelector('#grid-container .board'));
  var dotActive = document.activeElement.classList.contains("dot");
  var zeroIndexBoardSize = BOARD_SIZE - 1;
  var prevDot;
  
  function moveFocus(toNumber){
    if(prevDot){
      prevDot.removeAttribute("tabIndex");
    }
    dots[toNumber].setAttribute("tabIndex","0");
    dots[toNumber].focus();
    console.log("moving focus to " + toNumber + ".");
    prevDot = dots[toNumber];
  }
  
  // HANDLE D
  if(e.keyCode == keyboardD && dotActive){
    addDot(dots[activeDot], color);
  }
  
  // HANDLE D
  if(e.keyCode == keyboardD && dotActive){
    addDot(dots[activeDot], color);
  }
  
  // HANDLE E
  if(e.keyCode == keyboardE && dotActive){
    // HANDLE SPACE & ENTER  WHEN BOARD IS FOCUSED
    removeDot(dots[activeDot]);
  }
  
  // HANDLE SPACE & ENTER  WHEN BOARD IS FOCUSED
  if(e.keyCode == keyboardSpace   && boardFocused ||
     e.keyCode == keyboardEnter && boardFocused ){
    e.preventDefault(); 
    dots[0].setAttribute("tabIndex","0");
    dots[0].focus();
    console.log("set forus to dot one");
    activeDot = 0;
  }
  // HANDLE TAB  WHEN BOARD IS FOCUSED
  if(e.keyCode == 9 && boardFocused ){
    e.preventDefault(); 
    dots[0].setAttribute("tabIndex","0");
    dots[0].focus();
    console.log("set forus to dot one");
    activeDot = 0;
  }
  // HANDLE SPACE & ENTER  WHEN DOT IS FOCUSED
  if(e.keyCode == keyboardSpace && document.activeElement.classList.contains("dot") ||
     e.keyCode == keyboardEnter && document.activeElement.classList.contains("dot") && !boardFocused ){
    e.preventDefault(); 
    updatePixel(dots[activeDot], newDrawColor);
  }
  // HANDLE RIGHT ARROW 
  if(e.keyCode == keyboardRight && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(activeDot < dots.length - 1){
      activeDot++;
    }
    moveFocus(activeDot);
  }
  // HANDLE LEFT ARROW 
  if(e.keyCode == keyboardLeft && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(0 < activeDot){
      activeDot--;
    }
    moveFocus(activeDot);
  }
  // HANDLE DOWN ARROW 
  if(e.keyCode == keyboardDown && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(activeDot < dots.length - BOARD_SIZE){
      activeDot = activeDot + BOARD_SIZE;
    }
    moveFocus(activeDot);
  }
  // HANDLE UP ARROW 
  if(e.keyCode == keyboardUp && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log("testing if " + activeDot +" is greater than " +zeroIndexBoardSize);
    if(activeDot > zeroIndexBoardSize){
      activeDot = activeDot - BOARD_SIZE;
    }
    moveFocus(activeDot);
  }
}


// KEY DOWN
document.body.onkeyup = function(e){
  
}

function handleSpaceEnterPress(e) {
    "use strict";
  // pick passed event or global event object if passed one is empty
  e = e || event;
  var activeElement;
  console.log(e.keyCode);
  if (e.keyCode == 9) {
      // Here read the active selected link.
      activeElement = document.activeElement;
      // If HTML element is an anchor <a>
      console.log(activeElement);
      if (activeElement = document.querySelector('#grid-container .board'))
          // get it's hyperlink
          console.log("it's "+ activeElement);
  }
}

var body = document.querySelector('body');
body.addEventListener('keyup', checkTabPress);

  const focusedBoard = document.querySelector('#grid-container .name');
  isFocused(focusedBoard);  

function isFocused(elem){
  if (elem === document.activeElement) {
      console.log('Element has focus!');
      return true;
  } else {
      console.log(`Element is not focused.`);
      return false;
  }
}
//////// BIND CLICKS TO ACTIVE BOARD PIXELS

function bindClicksForCurrentBoard(){
  
  // BIND KEYBOARD CLICKS TO DOTS
  var pressed = false;
  const dots = document.querySelectorAll(".dot");
    
  Array.prototype.forEach.call(dots, function(dot, i) {
    dot.onmousedown = function() {
      pressed = true;
      updatePixel(dot, newDrawColor);
      undoStackReset();
      saveState();
    };
    dot.onmouseenter = function() {
      if (pressed == true) {
        updatePixel(dot, newDrawColor);
      }
    };
    dot.onmouseup = function() {
      pressed = false;
      updatePXON();
      undoStackAdd();
      updateUndoButton();
      saveState();
    };
    dot.onmouseout = function() {
      if (pressed == true) {
        // i don't think there's anything to cancel 
      }
    }
  });
  // In case mouse leaves board while pressed
  document.onmouseup = function() {
    pressed = false;
  };   

/// TOUCH STUFF 

  //target the container so we can track touch travel 
  dotBoard.addEventListener('touchstart', function(e){
    var target = e.target;
    pressed = true;
    if(target.classList.contains("dot")){
      updatePixel(target, newDrawColor);
    }
  }, false);
  
  dotBoard.addEventListener('touchmove', e => {
    var xPos = e.changedTouches[0].pageX;
    var yPos = e.changedTouches[0].pageY;
    // get element based on xy coordinates, draw if its a dot
    var currentlyTouched = document.elementFromPoint(xPos,yPos); 
    if(currentlyTouched.classList.contains("dot")){
      updatePixel(currentlyTouched, newDrawColor);
    }
  }, { passive: false });
  
  dotBoard.addEventListener('touchend', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
  
  dotBoard.addEventListener('touchcancel', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
}


      
//////// DRAW LOGIC
      
// UPDATE DOT ELEMENT USING ACTIVE TOOL
function updatePixel(dot, color) {
  if(currentTool == "erase"){
    removeDot(dot);
  }else{
    addDot(dot, color);
  }
}

// UPDATE DOT AT COORDINATE USING ACTIVE TOOL
function updatePixelAtCoordinate(x, y, color) {
  let foundDot = getPixelByCoordinate(x, y);
  if(currentTool == "erase"){
    removeDot(foundDot);
  }else{
    addDot(foundDot, color);
  }
}

// DRAW DOT AT COORDINATE 
function addPixelAtCoordinate(x, y, color) {
  let foundDot = getPixelByCoordinate(x, y);
  addDot(foundDot, color);
}

// ERASE DOT AT COORDINATE 
function removePixelAtCoordinate(x, y) {
  let foundDot = getPixelByCoordinate(x, y);
  removeDot(foundDot);
}

var prevDot, prevColor;

function addDot(dot, color){
  if(!color){
    color = "var(--currentNewDrawColor)"
  }
  if (dot != prevDot || color != prevColor){
    dot.style.cssText += `--glowColor:` + color + `;--dotColor:` + color + `;background-color: var(--dotColor);z-index:99;`;
    updatePXON();
  }else{
    return false;
  }
  prevDot = dot;
  prevColor = color
}
function removeDot(dot){
  dot.style.cssText = `z-index:1;`;
}
 
 
//////// UNDO LOGIC 

function undoStackAdd(){
  undoCount += 1;
  
  // ADD A CLONE OF THE GRID TO AN ARRAY
  gridContainer.firstElementChild.className = "board board" + undoStack.length;
  var gridContent = gridContainer.innerHTML;

  undoStack.push(gridContent);
  
  // // limit stack to 50?
  // if (undoStack.length > 50) {
  //   undoStack.length = 50;
  // }
  if (UNDO_VISUALIZER == true){
    var undoVisualizer = document.getElementById('undo-history');
    undoVisualizer.innerHTML = "";
    undoStack.forEach(element =>
      undoVisualizer.innerHTML += element
    );
  }
}

function undoStackReset(){
  if (currentUndoSpot > 0){
    undoStack = undoStack.slice(0,currentUndoSpot);
    // console.log("sliced to: " + undoStack.length);
    undoPresses = 0;
    undoCount = 0;
    undoSize = 0;
    currentUndoSpot = 0;
  }
}

function undoStackDelete(){
  undoStackReset()
  var undoBlocks = document.querySelectorAll("#undo-history .board");
  undoBlocks.forEach(block => 
    block.remove()
  );
}

// UPDATE UNDO BUTTON THINGS ON CHANGE
function updateUndoButton(currentSpot){
  if (undoCount > 0){
    undoButton.disabled = false;
    undoButton.style.opacity = 1;
    if (currentSpot == 0){
      undoButton.disabled = true;
      undoButton.style.opacity = .5;
    };
  } else{
    undoButton.disabled = true;
    undoButton.style.opacity = .5;
  }
}


// WHEN THE UNDO BUTTON IS PRESSED
document.getElementById("undo-button").onclick = function(){
  triggerUndo();
}; 

function triggerUndo(){
  // get size of undo array
  let undoSize = undoStack.length;
  
  // count how many times button was pressed
  undoPresses += 1;
  
  // get the target undo location (and location counting from 0 lol)
  currentUndoSpot = undoSize - undoPresses;        
  currentUndoSpotFromIndex = currentUndoSpot - 1;
  
  // put desired undo into the main editor
  document.getElementById('grid-container').innerHTML = undoStack[currentUndoSpotFromIndex];
  
  // light up current item in undo stack
  if (UNDO_VISUALIZER == true){
    let getLastUndoIndex = "board" + currentUndoSpotFromIndex;
    document.querySelectorAll(".board").forEach(
      function(board) {
        if (board.classList.contains(getLastUndoIndex)){
          board.style.border = "1px solid white"
        } else{
          board.style.border = "none";
        }
      }
    )
  }
  
  updateUndoButton(currentUndoSpotFromIndex);
  
  // re-set-up bindings 
  bindClicksForCurrentBoard();
}

 
 
 
//////// PXON STUFF 


function getCurrentPixels(){
  // get all current pixel elements (.dot class <div> items) and put them in an array
  var dots = document.querySelectorAll("#grid-container .dot");
  var currentBoard = [];
  dots.forEach(dot => 
    currentBoard.push(dot)
  );
   
  //
  //  Slice that array at each row of pixels, calculated from BOARD_SIZE.
  //  Each element in gridArray will be an array containing a row worth of pixel
  //  elements. This lets us get x,y coordinates from a previously flat list.
  //
  //  prev:
  //  currentBoard[]  = [{"‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢","‚Ä¢"}] 
  // 
  //  now:                     x0  x1  x2  ‚Ä¶
  //  gridArray[][] =  y0 [{[{"‚Ä¢","‚Ä¢","‚Ä¢",}],
  //                   y1   [{"‚Ä¢","‚Ä¢","‚Ä¢",}],
  //                   y2   [{"‚Ä¢","‚Ä¢","‚Ä¢"}]}] 
  //                   ‚Ä¶
  // 
  for(loop = 0; loop < BOARD_SIZE; loop++){
    if(loop < 1){
      gridArray[loop] = currentBoard.slice(0, BOARD_SIZE);
    }else{
      var oldVal = (loop) * BOARD_SIZE;
      var newVal = (loop + 1) * BOARD_SIZE;
      gridArray[loop] = currentBoard.slice(oldVal, newVal);
    }
  }
  return gridArray;
}

function getPixelByCoordinate(x,y){
  if( 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE){
    return gridArray[y][x];
  }else{
    console.log("coordinate (" + x + ", " + y + ") was out of bounds, setting to 0,0");
    return gridArray[0][0]
    return false;
  }
}

function updatePXON(){
  createPXON();
  pxonClean = JSON.stringify(pxon, undefined, 3)
  document.getElementById("raw").innerHTML = pxonClean;
  document.getElementById("export-pxon-textarea").innerHTML = pxonClean; 
  hasDrawn(hasDrawnSwitch)
} 

function hasDrawn(toggle){
  if(toggle == false){
    var beforeText = document.querySelectorAll(".before-drawing");
    var afterText = document.querySelectorAll(".after-drawing");  
    if(beforeText[0] && afterText[0]){
      beforeText[0].style.opacity = 0;
      beforeText[0].style.height = 0;
      afterText[0].style.display = "block";
      setTimeout(function(){
        beforeText[0].style.display = "none";
        afterText[0].style.opacity = 1;
        afterText[0].style.height = "auto";
      }, 500);
    }
    hasDrawnSwitch = true 
  }
}
// Export PXON
function createPXON(){
  var gridArray = getCurrentPixels();
  pxon = {
    exif: {
      software: "ryanwhitney.github.io/dotter",
      artist: "YOUR NAME HERE!",
      imageDescription: "DESCRIBE THE THING",
      userComment: "AND COMMENT ON IT",
      copyright: "do your name again ¬©",
      dateTime: new Date()
    },
    pxif: {
      pixels: []
    }
  };
  
  // Get color from each x,y coordinate
  var defaultColor = inputInitialDotColor.value
  function getpixelColor(pxArray){
    var xyPixelColor = pxArray[x][y].style.getPropertyValue('--dotColor');
    if(xyPixelColor.length > 0){
      return xyPixelColor;
    }
    else{
      return defaultColor;
    }
  }
  // From getCurrentPixels() we have an array element that contains arrays of each row of pixels. This lets us grab XY coordinates. 
  var n = 0;
  for(x = 0; x < BOARD_SIZE; x++){
    for(y = 0; y < BOARD_SIZE; y++){            
        var pixel = new Object();  
        pixel.x = (y * pxonScale); // we can agree to not talk
        pixel.y = (x * pxonScale); // about this part ok
        pixel.size = pxonScale;
        pixel.color = getpixelColor(gridArray);
        pxon.pxif.pixels[n] = pixel;
        n++;
    }
  }  
  return pxon;
}
      
      
      
function coordinateWithinBounds(coordinate){
  if(!coordinate.isNaN){
    if(0 <= coordinate && coordinate < BOARD_SIZE){
      return coordinate;
    }
  }
  console.log("received coordinate at " + coordinate + ". out of bounds, setting to 0.")
  return 0;
}

/////// API 

// potential: paint/draw, erase, square, line, getColor, border, updateDrawColor,updateBackgroundColor,updateBaseColor 
      
function paint(x,y,color){
  if(!color){
    color = newDrawColor;
  }
  addPixelAtCoordinate(x,y,color);
  undoStackAdd();
}
function draw(x,y,color){
  paint(x,y,color);
}

function erase(x,y){
  removePixelAtCoordinate(x, y);
}

function horizontal(y, color){
  if(!color){
    color = newDrawColor;
  }
  for(iter = 0; iter < BOARD_SIZE; iter++){
    updatePixelAtCoordinate(iter,y,color);
  }
  undoStackAdd();
}

function vertical(x, color){
  if(!color){
    color = newDrawColor;
  }
  for(iter = 0; iter < BOARD_SIZE; iter++){
    updatePixelAtCoordinate(x,iter,color);
  }
  undoStackAdd();
}

function square(x1,y1,x2,y2,color){
  if(!color){
    color = newDrawColor;
  }
  //do a switcharoo in case latter coordinates are closer to 0,0
  if(x1 > x2){
    let oldValHolder = x1; x1 = x2; x2 = oldValHolder;
  }
  if(y1 > y2){
    let oldValHolder = y1; y1 = y2; y2 = oldValHolder;
  }
  //draw rows to fill in the square
  for(xAxis = x1; xAxis <= x2; xAxis++){
    for(yAxis = y1; yAxis <= y2; yAxis++){
      // console.log("attempting to draw at (" + xAxis + ", " + yAxis + ")");
      updatePixelAtCoordinate(xAxis, yAxis, color);
    }
  }
  undoStackAdd();
}

function line(x1,y1,x2,y2,color){

};


//// PXON TO SVG

// Render a PXON document to SVG
// https://github.com/pxon/pxon-schema

function renderSVG(pxon, container) {

  // Remove existing
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
  
  
  const previewToPixelRatio = pxonScale / dotSize;
  var extraGap = inputGridGapSize.value * previewToPixelRatio * BOARD_SIZE;


  const svgns = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS (svgns, 'svg');
  svg.setAttribute('xmlns', svgns);
  svg.setAttribute('version', '1.1');
  svg.setAttribute('width', BOARD_SIZE * pxonScale + extraGap);
  svg.setAttribute('height', BOARD_SIZE * pxonScale + extraGap);

  const {
    pxif: { pixels }
  } = JSON.parse(pxon);
  
  
  const background = document.createElementNS(svgns, 'rect');
  background.setAttribute('x', 0);
  background.setAttribute('y', 0);
  background.setAttribute('rx', 3);
  background.setAttribute('width', BOARD_SIZE * pxonScale + extraGap);
  background.setAttribute('height', BOARD_SIZE * pxonScale + extraGap);
  background.setAttribute('fill', backgroundColor);
  
  svg.appendChild(background);
  
  var gridSpacer = 0;
  const gridGap = (inputGridGapSize.value * previewToPixelRatio);
  
  pixels.forEach((p) => {
    const ps = p.size;
    const pc = p.color;

    // Normalise x/y values to closest grid coordinate
    
    var px = ps * Math.ceil(p.x/ps);
    var py = ps * Math.ceil(p.y/ps);
    
    px = parseFloat(px) + (gridSpacer * gridGap);
    py = parseFloat(py) + (gridSpacer * gridGap);
    
    if(gridSpacer == BOARD_SIZE){
      gridSpacer = 0;
    }else{
      gridSpacer++;
    }
    
   
    
    const rx = (dotRadius * previewToPixelRatio);
    
    const pixel = document.createElementNS(svgns, 'rect');
    pixel.setAttribute('x', px);
    pixel.setAttribute('y', py);
    pixel.setAttribute('rx', rx);
    pixel.setAttribute('width', ps);
    pixel.setAttribute('height', ps);
    pixel.setAttribute('fill', pc);
    svg.appendChild(pixel);
    
  });
  container.appendChild(svg);
  document.getElementById('export-svg-textarea').value = svg.outerHTML;
}

function renderSVGfromExportWindow(){
  var oldSvg = document.getElementById('svg-output');
  if(oldSvg){
    oldSvg.remove();
  }
  const input = document.getElementById('export-pxon-textarea');
  const output = document.createElement('div');
  output.setAttribute('id', 'svg-output');
  document.getElementById('preview').appendChild(output);
  
  // input.oninput = function(e) {
    renderSVG(input.value, output);
  // }
  // Trigger initial render
  // input.dispatchEvent(new Event('input'));
}


// DOWNLOAD!? thank u https://stackoverflow.com/a/30832210
function download(data, filename, type) {
  var file = new Blob([data], {type: type});
  if (window.navigator.msSaveOrOpenBlob) // IE10+
      window.navigator.msSaveOrOpenBlob(file, filename);
  else { // Others
      var a = document.createElement("a"),
              url = URL.createObjectURL(file);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function() {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);  
      }, 0); 
  }
}

    </script>
  </body>
</html>
