<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
     <title>dotter</title>
    <!-- <script src="/dotter/neatcommands.js"></script> -->
    <link rel="stylesheet" href="highlight-styles/atelier-cave-light.css">
    <script  type="text/javascript" src="highlight-js-json.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/rangy/1.3.0/rangy-core.min.js" integrity="sha512-N+AGrlJCI4ov6LmtY/2SIm8kAcSAp9lhrYhVFmUhMBuFwQy3xEMNj+cPG4bg0N4XkL7Rw2+sKW8hg8v1MF5yLQ==" crossorigin="anonymous"></script> -->

    <!-- <script  type="text/javascript" src="rangy-selectionsaverestore.min.js"></script> -->


    <script>hljs.initHighlightingOnLoad();</script>
    <style>
//jStyle    
    /* CSS files add styling rules to your content */
    *{
      font-family:  SFMono-Regular, "SFMono-Regular", SFMono, Menlo,
        Monaco, Consolas,"Liberation Mono","Courier New", monospace;
        box-sizing: border-box;
    }
    html{
      overflow-x: hidden;
    }
    body {
      font-family: helvetica, arial, sans-serif;
      margin: 0;
      font-size: 12px;
      background-color: #000;
      transition: background-color .3s ease;
      --textColor: white;
      overflow-x: hidden;
      display: flex;
    }
    
    .draw-color{
      color: var(--currentNewDrawColor)
    }
    
    header{
      
    }
    h1{
      color: var(--currentNewDrawColor);
      text-transform: lowercase;
      text-align: center;
    }
    #dotter-num{
      font-size: 19px;
      font-weight: 100;
      position: relative;
      top: -.5px;
    }
    header button{
      font-size: 19px;
      font-weight: 100;
      position: relative;
      top: -4px;
    }
    th{
      font-weight: normal;
    }
    p{
      line-height: 1.5;
    }
    #keyboard-shortcuts table{
      margin: auto;
      padding: 0;
      border: 0;
      outline: 0;
    }
    td:nth-child(even){
      padding: 5px 15px 5px 5px;
    }
    .key{
      display: inline-block;
      border: 1px solid rgba(255,255,255,.4);
      border-radius: 3px;
      padding: 1px 5px;
      margin: 0 2px;
      color: var(--textColor);
    }
    #main{
      flex: 1;
    }
    #code-editor-input .comment{
      color: var(--textColor) !important;
      opacity: .8;
      position: relative;
      top: -6px;
    }
    #export-window{
      z-index: 999009;
      width: 80%;
      height: 80%;
      display: none;
      position: fixed;
      flex-direction: column;
      top: 50%;
      left: 50%;
      padding: 20px;
      /* bring your own prefixes */
      transform: translate(-50%, -50%);
      background-color: grey;
    }
    .overlay{
      height: 100%;
      width: 100%;
      position: fixed; /* Stay in place */
      z-index: 99999;
      display: none;
      touch-action: none;
      left: 0;
      top: 0;
      background-color: var(--bgColor);
      filter: brightness(0.2);
      opacity: .4;
    }
    .modal-inner{
      display: flex;
      flex: 1;
      height: 100%;
    }
    .modal-inner > div{
      flex: 1;
    }
    .modal-inner textarea{
      display: flex;
      height: 400px;
      flex: 1;
      width: 80%;
    }
    #pxon-scale{
      position: absolute;
      right: 85px;
      top: 7.5px;
    }
    #copy-pxon{
      position: absolute;
      right: 5px;
      top: 5px;
    }
    #pxon-panel, #instruction-panel{
      display: flex;
      flex-direction: column;
      line-break: normal;
      float: right;
      width: 40%;
      display:  inline;
      position:absolute;
      top:-99999px;
      z-index: 1;
      color: var(--textColor);
      transition: width .2s ease-in-out;
      border-left: 1px solid rgba(255,255,255,.03);
      background: var(--bgColor);
    }
    #pxon-panel .right-panel-text{
      padding: 0 20px 20px;
      margin-top: 50px;
    }
    #pxon-panel a{
      color: var(--currentNewDrawColor);
      font-style: italic;
      position: relative;
      transition: all .2s ease;
      bottom:0;
    }
    #pxon-panel a:hover{
      bottom: 2px;
    }
    #raw{
      overflow: hidden;
      overflow-y: scroll;
      background: none;
      border: none;
      height: 100%;
      color: var(--textColor);
    }
    input,label, button{
      text-transform: lowercase;
      font-size: 13px;
      color: var(--textColor);
    }
    label{
      padding-bottom: 5px;
    }
    input{
      font-size:16px;
    }
    .tools{
      display: flex;
      margin: 5px;
      padding-bottom: 10px;
      justify-content: space-around;
      align-items: flex-end;
      max-width: 500px;
      margin: 0 auto;
      padding: 20px 0 10px;
    }
    .tools label{
      display: block;
      line-height: 1.5;
    }
    .tools.colors div, .tools.sizing div{
      text-align: center;
    }
    #select-draw-erase label{
      display: inline-block;
    }
    #preview {
      flex: unset;
    }
    #preview #svg-output{
      border: 1px solid var(--bgColor);
      background-color: var(--bgColor);
      display: flex;
      overflow: visible;
      border-radius: 3px;
      box-shadow: 0 0 9px rgba(0,0,0,.2),0 0 3px rgba(0,0,0,.3),0 0px 1px rgba(0,0,0,..2),0 0px 125px -25px var(--bgColor),0 0px 25px 0px rgba(0,0,0,.3);
    }
    #preview-pane{
      position: absolute;
      display: none;
      top: 0;
      right: 0;
    }
    #preview-pane .board{
      grid-gap: 1px 1px;
      grid-template-rows: repeat(16, 3px);
      grid-template-columns: repeat(16, 3px);
      border-radius: .1;
    }
    #preview-pane .board .dot[style]{
      border-radius: .1px !important;
    }
    #grid-container{
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
       -khtml-user-select: none; /* Konqueror HTML */
         -moz-user-select: none; /* Old versions of Firefox */
          -ms-user-select: none; /* Internet Explorer/Edge */
              user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
      margin-bottom: 10px;
      opacity: 1;
      transform: scale3d(1,1,1);
    }
    #grid-container .board{
      margin: auto;
      touch-action: none;
      outline: none;
    }
    .board-container{
      display: flex;
      justify-content:space-around;
      align-content: center;
    }
    .board{
      display: grid;
      grid-gap: 3px 3px;
      grid-template-rows: repeat(16, 20px);
      grid-template-columns: repeat(16, 20px);
    }
    .dot{
      background-color: #19181A;
      border: 1px solid rgba(255,255,255,0);
      background-color: rgba(0,0,0,0);
      transition: none;
    }  
    input[type=color]{
      /* border: none;
      background-color: transparent; */
    }
    input[type=number]{
      background-color:transparent;
      width: 60px;
    }
    input[type=submit]{
      margin-top: 10px;
      background-color:transparent;
      border-width: 1px;
      border-color: var(--currentNewDrawColor) !important;
      float: right;
      color: var(--textColor);
    }
    #draw-with-words{
      margin: 40px auto 20px;
      width: 364px;
      padding-bottom: 50px;
      color: var(--textColor);
    }
    code{
      width: 364px;
      min-height: 150px;
      border: 1px solid var(--currentNewDrawColor);
      line-height: 1.5;
      border-radius: 6px;
      display: block;
      margin: auto;
      padding: 20px;
      text-align: left;  
      text-transform: unset !important;    
    }
    code {
      /* color: var(--currentNewDrawColor) !important; */
      text-align: left;      
      text-transform: unset !important;
    }
    span.code{
      color: var(--currentNewDrawColor);
    }    
    button{
      background-color: black;
      border-width: 1px;
      color: var(--textColor);
    }
    #more-tools{
      display: flex;
      align-items: flex-start;
      text-align: center;
    }
    #more-tools label{
      display: block;
    }
    #undo-visualizer * {
      display: inline-block;
    }
    #undo-visualizer #undo-tile-scale, 
    #undo-visualizer #undo-tile-gap{
      display: none;
    }
    #undo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #redo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #undo-history:first-child { margin-top: auto }
    #undo-history{
      display: flex;
      flex-direction: row-reverse;
      justify-content:  flex-end;
      flex-wrap: nowrap;
      white-space: nowrap;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,.2);
      padding: 10px;
      max-width: 95%;
      overflow-x: scroll;
      margin: 30px auto 0;
    }
    #undo-history .board{
      grid-gap: 0 0;
      margin-right: 10px;
      grid-template-rows: repeat(16, 2px);
      grid-template-columns: repeat(16, 2px);
    }
    #undo-history .dot[style]{
      box-shadow: none !important;
    }
    .before-drawing{
      height: auto;
      display: block;
      opacity: 1;
      transition: all .5s ease;
    }
    .after-drawing{
      height: 0;
      display: none;
      opacity: 0;
      transition: all .5s ease;
    }
    
    #hide-checkbox:checked + label {
      transform: scale(2, 3);
      position: relative;
      left: -5px;
      bottom: -5px;
      font-size: 10px;
    }
    #preview #svg-output{
      transform-origin-x: 0;
      transform-origin-y: 0;
    }
    @media only screen and (min-width: 440px) {
      input,label, button{
        text-transform: lowercase;
        font-size:14px;
        color: var(--textColor);
      }

    }
    </style>
  </head>  
  <body>
    <button onclick="clearBoard();" style="position: absolute;top:10;left:10;">clear</button>
    <div id="export-window">
      <h2>Export your dots to PXON or SVG</h2>
      <button id="close-export-modal">close this</button>
      <div class="modal-inner">
        <div id="export-pxon">
          <p>Here's your pxon</p>
          <textarea id="export-pxon-textarea"></textarea>
        </div>
        <div id="export-svg">
          <p>Here's your svg</p>
          <textarea id="export-svg-textarea"></textarea>
        </div>
        <div id="preview">
          <p>Here's your preview</p>
          <div id="svg-preview"></div>
          <button id="download-svg">Download SVG</button> 
          <button id="copy-link-to-replay">Copy link to animated replay </br> (this may not work!)</button> 
          <button id="download-pxon">Download PXON</button> 
        </div>
      </div>
    </div>
    <div id="overlay-backdrop" class="overlay"></div>
    <div id="main">
      <header><a href="/dotter/">
        <h1>DOTTER <button id="dotter-up">⌃</button><span id="dotter-num">16</span><button id="dotter-down">⌄</button></h1>
        </a>
      </header>
      <div  id="grid-container" class="board-container"></div>
      <button id="color-eyedropper">🎯</button>
      <pre id="code-editor-console" style="text-align:center;opacity: .4;margin-top: 0;white-space: pre-wrap;"></pre>
      <div id="keyboard-shortcuts">
        <small style="text-align: center;display: block;opacity: .7;">tab to activate board</small>
        <table>
          <colgroup span="2"></colgroup>
          <colgroup span="2"></colgroup>
          <colgroup span="2"></colgroup>
          <colgroup span="2"></colgroup>
          <tr>
            <th 
              colspan="2" 
              scope="colgroup"  
              aria-label="column of shortcuts"
            ></th>
            <th 
              colspan="2" 
              scope="colgroup"  
              aria-label="column of shortcuts"
            ></th>
            <th 
            colspan="2" 
            scope="colgroup"  
            aria-label="column of shortcuts"
          ></th>
          <th 
            colspan="2" 
            scope="colgroup"  
            aria-label="column of shortcuts"
          ></th>
          </tr>
          <tr>
            <th scope="col" aria-label="key"></th>
            <th scope="col" aria-label="command"></th>
            <th scope="col" aria-label="key"></th>
            <th scope="col" aria-label="command"></th>
            <th scope="col" aria-label="key"></th>
            <th scope="col" aria-label="command"></th>
            <th scope="col" aria-label="key"></th>
            <th scope="col" aria-label="command"></th>
          </tr>
          <tr>
            <th scope="td"><span class="key">←</span></th>
            <td>left</td>
            <th scope="td"><span class="key">→</span></th>
            <td>right</td>
            <th scope="td"><span class="key">d</span></th>
            <td>draw</td>
            <th scope="td"><span class="key">h</span></th>
            <td>draw horizontal line</td>
          </tr>
          <tr>
            <th scope="td"><span class="key">↓</span></th>
            <td>down</td>
            <th scope="td"><span class="key">↑</span></th>
            <td>up</td>
            <th><span class="key">e</span></td>
            <td>erase</td>
            <td><span class="key">v</span></td>
            <td>draw vertical line</td>
          </tr>
        </table>
      </div>
      <div id="preview-pane"></div>
      <div class="tools colors">
        <div id="initial-dot-color-select">
          <label for="initial-dot-color-selected">Base color</label>
          <input type="color" id="initial-dot-color-selected" name="select-initial-dot-color" class="color-picker" value="#1f1f1f" tabIndex="0"/>
        </div>
        <div id="color-select">
          <label for="color-selected">Draw Color</label>
          <input type="color" id="color-selected" class="color-picker" name="select-color" value="#7a59ff" tabIndex="0"/>
        </div>
        <div id="background-select">
          <label for="background-color-selected">Background Color</label>
          <input type="color" id="background-color-selected" name="select-background-color" class="color-picker" value="#19181A" tabIndex="0"/>
        </div>
      </div>
      <div class="tools sizing">
        <div id="select-dot-size" >
          <label for="dot-size">dot size</label>
          <input type="number" id="dot-size" name="select-dot-size"
             value="20">
        </div>
        <div id="select-dot-radius-amount">
          <label for="dot-radius-amount">dot radius</label>
          <input type="number" id="dot-radius-amount" name="select-dot-radius-amount"
             value="3" >
        </div>
        <div id="select-grid-gap-size">
          <label for="grid-gap-size">grid gap</label>
          <input type="number" id="grid-gap-size" name="select-grid-gap-size"
             value="3" >
        </div>
        <div id="select-glow-amount">
          <label for="glow-amount">glow</label>
          <input type="number" id="glow-amount" name="select-glow-amount"
             value="0">
        </div>
      </div>
      <div class="tools-container">
        <div class="tools modes">
          <div id="select-draw-erase">
            <input type="radio" id="select-draw-radio" name="draw-erase-radio" value="draw" / checked>
            <label for="select-draw-radio">draw</label><br/>
            <input type="radio" id="select-erase-radio" name="draw-erase-radio" value="erase" />
            <label for="select-erase-radio">erase</label>
          </div>
          <div class="undo">
            <button id="undo-button" disabled>undo</button>
          </div>
          <div class="redo">
            <button id="redo-button" disabled>redo</button>
          </div>
          <div>
            <button id="open-save-export-button">save/export</button>
          </div>
        </div>
        <div id="more-tools" class="tools">
          <!-- <div class="check">
            <input type="checkbox" id="hide-checkbox" name="hide">
            <label for="hide-checkbox">minimize</label>
          </div> -->
          <div class="check experiment">
            <input type="checkbox" id="code-editor-checkbox" name="code-editor-checkbox" checked>
            <label for="code-editor-checkbox">draw with words</label>
          </div>
          <div class="check experiment">
            <input type="checkbox" id="enable-instruction-viewer" name="enable-instruction-viewer">
            <label for="enable-instruction-viewer">Instruction viewer</label>
          </div>
          <div class="check experiment">
            <input type="checkbox" id="enable-pxon-viewer" name="enable-pxon-viewer">
            <label for="enable-pxon-viewer">PXON viewer</label>
          </div>
          <div id="undo-visualizer" class="check experiment">
            <input type="checkbox" id="enable-undo-visualizer" name="enable-undo-visualizer">
            <label for="enable-undo-visualizer">undo stack visualizer</label>
            <div id="undo-tile-scale">
              <span>(🚧 disable if slow)</span>
              <label for="select-undo-tile-scale">&nbsp;&nbsp; scale</label>
              <input type="number" id="select-undo-tile-scale" name="select-undo-tile-scale" value="2" style="width:40px;">
            </div>
            <div id="undo-tile-gap">
              <label for="select-undo-tile-gap">&nbsp;&nbsp; gap</label>
              <input type="number" id="select-undo-tile-gap" name="select-undo-tile-gap" value="0" style="width:40px;">
            </div>
          </div>
        </div>
      </div>
      <div id="draw-with-words">
        <p><span style="font-size:12px">⚠️</span> heads up this is just javascript</p>
        <p>but also with extra functions available, like:</p>
        <p>
          <span class="code">paint(<b>x</b>,<b>y</b>);</span><br/>
          <span class="code">square(<b>x1</b>,<b>y1</b>,<b>x2</b>,<b>y2</b>);</span><br/>
          <span class="code">horizontal(<b>y</b>);</span><br/>
          <span class="code">vertical(<b>x</b>);</span><br/>
        </p>
        <p>just replace <b>x</b> and <b>y</b> with coordinates.</p>
        <p>bonus: all of these take color (string) as an optional parameter.</p>
        <pre>
<code name="code-editor" id="code-editor-input" contenteditable="true" autocapitalize="off" autocomplete="off" spellcheck="false" class="javascript">// try <strong>paint(0,1,"red");</strong> below 
// or, submit the existing code ✨

for(i=0;i<16;i++){
  // multiply the hue each iteration. 20
  // keeps it under the max value for hsv()
  let color = "hsl("+ i*20 +",65%,70%)";
  horizontal(i, color);
};
</code>
      </pre>
      <input id="submit-code-button" type="submit" value="run the code" title="run the code, do it" />
      <button onclick="codeEditorInput.innerHTML=moreRainbowCode;hljs.highlightBlock(codeEditorInput);">🌈</button>
      
        <!-- <pre>
paint(x,y,color)
  x = (number) x coordinate
  y = (number) y coordinate
  color = (string) optional. color in hex "#ffffff" format
  
square(x1,y1,x2,y2,color)
  x1 = (number) x coordinate
  y1 = (number) y coordinate
  x2 = (number) x coordinate
  y2 = (number) y coordinate
  color = (string) optional. color in hex "#ffffff" format
        </pre> -->
      </div>
    </div>
    <div id="instruction-panel">
      <button id="copy-instruction">copy url</button>

      <textarea style="height:1000px;" id="instructions"></textarea>
    </div>
    <div id="pxon-panel">
      <div class="pxon-panel-top">
        <div id="pxon-scale">
          <label for="select-pxon-scale">pxon scale:</label>
          <input type="number" id="select-pxon-scale" value="1" style="width:40px;"/>
        </div>
        <div class="right-panel-text">
          <div class="before-drawing">
            <p>first, you must draw.</p>
          </div>
          <div class="after-drawing">
            <p><b class="draw-color">CONGRATS</b></p>
            <p>You've made <a href="http://jennmoney.biz/pxon">PXON</a>.</p>
            <p>The text below is editable. you'll find copy and download buttons above and to the right.</p>
            <p>Adjust the scale of your pxon, if you'd like!</p>
          </div>
        </div>
        <button id="copy-pxon">copy</button>
      </div>
      <textarea id="raw"></textarea>
    </div>
    
    
<script>









function sleep(milliseconds) { 
  let timeStart = new Date().getTime(); 
  while (true) { 
      let elapsedTime = new Date().getTime() - timeStart; 
      if (elapsedTime > milliseconds) { 
          break; 
      } 
  }
}

var gridContainer,
  undoStack = [],
  gridArray = [],
  gridContainer = document.getElementById('grid-container'),
  undoPresses = 0,
  undoCount = 0,
  undoButton = document.getElementById("undo-button"),
  openSaveExportButton = document.getElementById("open-save-export-button"),
  closeExportModal = document.getElementById("close-export-modal"),
  overlayBackdrop = document.getElementById("overlay-backdrop"),
  BOARD_SIZE = 16,
  dotBoard,
  dotCount,
  currentTool,
  hasDrawnSwitch = false,
  pxonScale = 10,
  color,
  undoSize,
  currentUndoSpot,
  currentUndoSpotFromIndex,
  UNDO_VISUALIZER = false; 

//////// SET UP OPTIONS + USER INPUTS

var inputInitialDotColor = document.getElementById("initial-dot-color-selected"),
  inputNewDrawColor = document.getElementById("color-selected"),
  inputBackgroundColor = document.getElementById("background-color-selected"),
  inputDotSize = document.getElementById("dot-size"),
  inputDotRadius = document.getElementById("dot-radius-amount"),
  inputGridGapSize = document.getElementById("grid-gap-size"),
  inputGlowRadius = document.getElementById("glow-amount"),
  inputDrawEraseRadio = document.getElementById("draw"),
  inputHideCheckbox = document.getElementById("hide-checkbox"),
  inputInstructionViewerCheckbox = document.querySelector("input[name=enable-instruction-viewer]"),

  inputPxonViewerCheckbox = document.querySelector("input[name=enable-pxon-viewer]"),
  inputPxonScale = document.getElementById("select-pxon-scale")
  inputCodeEditorCheckbox = document.getElementById("code-editor-checkbox")
  inputUndoVisualizerCheckbox = document.querySelector("input[name=enable-undo-visualizer]"),
  inputUndoVisualizerScaleContainer = document.getElementById("undo-tile-scale"),
  inputUndoVisualizerScale = document.getElementById("select-undo-tile-scale"),
  inputUndoVisualizerGapContainer = document.getElementById("undo-tile-gap"),
  inputUndoVisualizerGap = document.getElementById("select-undo-tile-gap");

function deleteBoard() {
  if (confirm("Are you sure you want to delete this board? It…cannot be undone.")) {
    var board = document.querySelectorAll("#grid-container .board");
    board[0].remove();
    startup();
  } else {
    return false;
  }
}

var initialDotColor,
  newDrawColor,
  backgroundColor,
  dotSize,
  dotRadius,
  gridGapSize,
  glowRadius,
  hideCheckbox,
  instructionViewerCheckbox,
  pxonViewerCheckbox,
  codeEditorCheckbox,
  undoVisualizerCheckbox,
  undoVisualizerScale,
  undoVisualizerGap;
  
  var defaultOptions = {
    initialDotColor: "#1f1f1f",
    newDrawColor: "#7a59ff", //ffa57d
    backgroundColor: "#19181a",
    dotSize: 20,
    dotRadius: 3,
    gridGapSize: 3,
    glowRadius: 0,
    hideCheckbox: false,
    instructionViewerCheckbox: false,
    pxonViewerCheckbox: false,
    pxonScale: 1,
    codeEditorCheckbox: true,
    undoVisualizerCheckbox: false,
    undoVisualizerScale: 2,
    undoVisualizerGap: 0,
    currentTool: "draw"
  }

function getState(){
  initialDotColor = localStorage.getItem("initialDotColor") | inputInitialDotColor.value;
  newDrawColor = inputNewDrawColor.value;
  backgroundColor = localStorage.getItem("backgroundColor") | inputBackgroundColor.value;
  dotSize = inputDotSize.value;
  dotRadius = inputDotRadius.value;
  gridGapSize = inputGridGapSize.value;
  hideCheckbox = inputHideCheckbox.checked;
  glowRadius = inputGlowRadius.value;
  instructionViewerCheckbox = inputInstructionViewerCheckbox.checked;
  pxonViewerCheckbox = inputPxonViewerCheckbox.checked;
  codeEditorCheckbox = inputCodeEditorCheckbox.checked;
  undoVisualizerCheckbox = inputUndoVisualizerCheckbox.checked;
  undoVisualizerScale = inputUndoVisualizerScale.value;
  undoVisualizerGap = inputUndoVisualizerGap.value;
}


function loadState(){
  if (typeof(Storage) !== "undefined") {
    initialDotColor = localStorage.getItem("initialDotColor");
    newDrawColor = localStorage.getItem("newDrawColor");
    backgroundColor = localStorage.getItem("backgroundColor");
    dotSize = localStorage.getItem("dotSize");
    dotRadius = localStorage.getItem("dotRadius");
    gridGapSize = localStorage.getItem("gridGapSize");
    glowRadius = localStorage.getItem("glowRadius");
    hideCheckbox = localStorage.getItem("hideCheckbox");
    codeEditorCheckbox = localStorage.getItem("codeEditorCheckbox");
    instructionViewerCheckbox = localStorage.getItem("instructionViewerCheckbox");
    pxonViewerCheckbox = localStorage.getItem("pxonViewerCheckbox");
    undoVisualizerCheckbox = localStorage.getItem("undoVisualizerCheckbox");
    undoVisualizerScale = localStorage.getItem("undoVisualizerScale");
    undoVisualizerGap = localStorage.getItem("undoVisualizerGap");
  } else {
    // no localstorage..
  }
  
}

function applyState(){
  updateInitialDotColor(initialDotColor)
}

function saveState(){
  if (typeof(Storage) !== "undefined") {
    localStorage.setItem("initialDotColor", initialDotColor);
    localStorage.setItem("newDrawColor", newDrawColor);
    localStorage.setItem("backgroundColor", backgroundColor);
    localStorage.setItem("dotSize", dotSize);
    localStorage.setItem("dotRadius", dotRadius);
    localStorage.setItem("gridGapSize", gridGapSize);
    localStorage.setItem("glowRadius", glowRadius);
    localStorage.setItem("hideCheckbox", hideCheckbox);
    localStorage.setItem("codeEditorCheckbox", codeEditorCheckbox);
    localStorage.setItem("pxonViewerCheckbox", pxonViewerCheckbox);
    localStorage.setItem("undoVisualizerCheckbox", undoVisualizerCheckbox);
    localStorage.setItem("undoVisualizerScale", undoVisualizerScale);
    localStorage.setItem("undoVisualizerGap", undoVisualizerGap);  
  } else {
    // no localstorage..
  }
  
}

// hex to hsl copyright uhhh stack overflow
function unhex(hex){
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  r = parseInt(result[1], 16);
  g = parseInt(result[2], 16);
  b = parseInt(result[3], 16);
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if(max == min){
    h = s = 0; // achromatic
  }else{
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch(max){
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  var HSL = new Object();
  HSL['h']=h;
  HSL['s']=s;
  HSL['l']=l;
  return HSL;
}

// Bind to input changes on INITIAL dot color  
inputInitialDotColor.addEventListener("input", function() {
  updateInitialDotColor(inputInitialDotColor.value);
}, false); 
   
// Bind to input changes on NEW DRAW color  
inputNewDrawColor.addEventListener("input", function() {
  updateNewDrawColor(inputNewDrawColor.value);
}, false); 
      
// Bind to input changes on BACKGROUND color 
inputBackgroundColor.addEventListener("input", function() {
  updateBackgroundColor(inputBackgroundColor.value);
}, false); 

// Bind to input changes on DOT RADIUS
inputDotRadius.addEventListener("input", function() {
  updateDotRadius(inputDotRadius.value);
}, false); 

function updateDotRadius(amount){
  if(!amount){
    amount = 3;
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        border-radius:` + inputDotRadius.value + `px;
    }`;     
  document.head.appendChild(style);
  // update variable
  dotRadius = amount;
  // update input value
  inputDotRadius.value = amount;
  // save state
  saveState();
}

// Bind to input changes on DOT SIZE
inputDotSize.addEventListener("input", function() {
  updateDotScale(inputDotSize.value);
}, false); 

// Handle changes to DOT SIZE
function updateDotScale(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 20;
  }
  var n = sizeInPx + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #grid-container .board{
      grid-template-rows: repeat(` + BOARD_SIZE + `, ` + n + `);
      grid-template-columns: repeat(` + BOARD_SIZE + `, ` + n + `);
    } `;   
  document.head.appendChild(style);
  // update variable
  dotSize = sizeInPx;
  // update input value
  inputDotSize.value = sizeInPx;
  // save state
  saveState();
}

// Bind to input changes on GRID GAP 
inputGridGapSize.addEventListener("input", function() {
  updateGridGapSize(inputGridGapSize.value);
}, false);

function updateGridGapSize(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 3;
  }
  const style = document.createElement('style');
  if (sizeInPx > 0){
    style.innerHTML = `
      #grid-container .board {
          grid-gap: `  + sizeInPx + `px `  + sizeInPx + `px;
      }`;     
  }else{
    style.innerHTML = `
    #grid-container .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateDotScale(dotSize - 1);
  setTimeout(function(){ 
    updateDotScale(dotSize + 1); 
  }, 15);
  // update variable
  gridGapSize = amount;
  // update input value
  inputGridGapSize.value = amount;
  // save state
  saveState();
}
var wnumb = 'ed553bc94f1e0b6c72' 
// Bind and handle input changes on GLOW AMOUNT
inputGlowRadius.addEventListener("input", function() {
  updateGlowRadius(inputGlowRadius.value);
}, false); 

// Handle changes to GLOW AMOUNT
function updateGlowRadius(amount){
  if(!amount){
    amount = 0;
  }
  var dots = document.querySelectorAll(".dot");
  dots.forEach(item => 
    item.style.cssText += `box-shadow: 0 0 ` + amount + `px  var(--glowColor),
         0 0 ` + amount + `px  var(--glowColor);`
  );
  // update variable
  glowRadius = amount;
  // update input value
  inputGlowRadius.value = amount;
  // save state
  saveState();
}

// Bind to changes on DRAW / ERASE RADIO
var drawEraseRadios = document.querySelectorAll('input[name=draw-erase-radio]');
if(drawEraseRadios.length) {
  for(count = 0; count < drawEraseRadios.length; count++){
    drawEraseRadios[count].addEventListener('change', function() {
        currentTool = this.value;
    });
  }
}

// Bind to clicks on save/export button
openSaveExportButton.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

closeExportModal.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

overlayBackdrop.addEventListener( 
  'click',
  function() {
    toggleExportWindow();
  }
);

function toggleExportWindow(){
  var exportWindow = document.getElementById("export-window");
  if (exportWindow.style.display != "block"){
    updatePXON();
    renderSVGfromExportWindow();
    exportWindow.style.display = "block";
    overlayBackdrop.style.display = "flex";
  } else {
    exportWindow.style.display = "none"
    overlayBackdrop.style.display = "none"

  }
}

// Bind & handle changes on PXON VIEWER CHECKBOX
inputInstructionViewerCheckbox.addEventListener( 
  'change',
  function() {
    updateInstructionViewerCheckbox(this);
  }
);
// Bind & handle changes on PXON VIEWER CHECKBOX
inputPxonViewerCheckbox.addEventListener( 
  'change',
  function() {
    updatePxonViewerCheckbox(this);
  }
);



/// COLOR PICKER 
var pressed;
document.getElementById("color-eyedropper").addEventListener("click",function(e){
  body.style.cursor = "crosshair";
  function getBackgroundColor(dot, event){
    if(event.target.classList.contains("dot")){
      let color = getComputedStyle(dot).getPropertyValue("--dotColor");
      document.getElementById("color-selected").value = color ;
    }
  }
  Array.prototype.forEach.call(dots, function(dot, i) {
    dot.onmousedown = function(event) {
      pressed = true;
      getBackgroundColor(dot, event);
      saveState();
    };
    dot.onmouseenter = function() {
      dot.style.border = "1px solid rgba(255,255,255,.1)"

      if (pressed == true) {
        getBackgroundColor(dot, event);
      }
    };
    dot.onmouseup = function() {
      pressed = false;
      saveState();
    };
    dot.onmouseout = function() {
      dot.style.border = "1px solid rgba(255,255,255,0)"
      if (pressed == true) {
        // i don't think there's anything to cancel 
      }
    }
    document.getElementById("color-eyedropper").addEventListener("click",function(e){
      bindClicksForCurrentBoard();
    });
  });
  // In case mouse leaves board while pressed
  document.onmouseup = function() {
    pressed = false;
  };   
  
})


var dotterNumButtons = document.querySelectorAll("header button");

dotterNumButtons[0].addEventListener('click',function(){
  BOARD_SIZE++;
  document.getElementById('dotter-num').innerHTML = BOARD_SIZE;
  startup();
})
dotterNumButtons[1].addEventListener('click',function(){
  BOARD_SIZE--;
  document.getElementById('dotter-num').innerHTML = BOARD_SIZE;
  startup();
})

// Bind & handle changes on PXON VIEWER CHECKBOX
inputPxonScale.addEventListener( 
  'change',
  function() {
    updatePxonScale(inputPxonScale.value);
  }
);

function updatePxonScale(number){
  pxonScale = number;
  // console.log(pxonScale);
  updatePXON();
}


function updateInstructionViewerCheckbox(input){
  instructionContainer = document.getElementById("instruction-panel");
  if(input){
    if(input.checked) {
      instructionContainer.style.display = "flex";
      instructionContainer.style.width = "40%";
      inputInstructionViewerCheckbox.checked = input.checked;
    } else {
      instructionContainer.style.display = "none";
      instructionContainer.style.width = "0";
      inputInstructionViewerCheckbox.checked = input.checked;
    }
  }else{
    instructionContainer.style.display = "none";
    instructionContainer.style.width = "0";
    inputInstructionViewerCheckbox.checked = false;
  }  
}
function updatePxonViewerCheckbox(input){
  pxonContainer = document.getElementById("pxon-panel");
  if(input){
    if(input.checked) {
      pxonContainer.style.display = "flex";
      pxonContainer.style.width = "40%";
      inputPxonViewerCheckbox.checked = input.checked;
    } else {
      pxonContainer.style.display = "block";
      inputPxonViewerCheckbox.checked = input.checked;
    }
  }else{
    pxonContainer.style.display = "none";
    pxonContainer.style.width = "0";
    inputPxonViewerCheckbox.checked = false;
  }  
}

// Set up copy instruction button
copyInstructionButton = document.getElementById("copy-link-to-replay");

copyInstructionButton.addEventListener("click", function(){
  
  var getUrl = window.location;
  var baseUrl = getUrl .protocol + "//" + getUrl.host + "/" + getUrl.pathname.split('/')[1];
  console.log(baseUrl);
  
  var instructionsInput = document.getElementById("instructions"); 
  
  var instructionOutputPre = instructionsInput.innerHTML;
  
  var compressed=en(instructionOutputPre)

  var instructionOutputSegment =  encodeURIComponent(compressed);
    
  instructionsInput.innerText = baseUrl + "?instructions=" + instructionOutputSegment;
  
  


  instructionsInput.focus();
  instructionsInput.select();
  try {
    let successful = document.execCommand('copy');
    let msg = successful ? 'successful' : 'unsuccessful';
    copyInstructionButton.innerText = "successfully copied!";
    setTimeout(function(){
      copyInstructionButton.innerText = "copy link to animated replay again";
    }, 1500);
  } catch(err) {
    alert('failed to copy. ☹️ … ' + err);
  }

})
// Set up copy pxon button
copyPxonButton = document.getElementById("copy-pxon");

copyPxonButton.addEventListener("click", function(){
  pxonOutputPre = document.getElementById("raw");
  var copiedPxon = pxonOutputPre;
  copiedPxon.focus();
  copiedPxon.select();
  try {
    let successful = document.execCommand('copy');
    let msg = successful ? 'successful' : 'unsuccessful';
    copyPxonButton.innerText = "successfully copied!";
    setTimeout(function(){
      copyPxonButton.innerText = "copy again";
    }, 1500);
  } catch(err) {
    alert('failed to copy. ☹️ … ' + err);
  }

})
// 
// // Bind & handle changes on PXON VIEWER CHECKBOX
// inputHideCheckbox.addEventListener( 
//   'change',
//   function() {
//     var otherCheckBoxes = document.querySelectorAll("#more-tools .experiment");
//     if(this.checked) {
//       otherCheckBoxes.forEach(element =>
//         element.style.display = "none"
//       );
//     } else {
//       otherCheckBoxes.forEach(element =>
//         element.style.display = "unset"
//       );
//     }
//       
//       
//   }
// );





var codeEditorInputFocused = isFocused(document.querySelector('#code-editor-input'));


var codeEditorInput = document.getElementById("code-editor-input");
var oldCurserPosition;
function setChangeListener (codeEditorInput, listener) {
  codeEditorInput.addEventListener("blur", listener);
  codeEditorInput.addEventListener("keyup", listener);
  codeEditorInput.addEventListener("paste", listener);
  codeEditorInput.addEventListener("copy", listener);
  codeEditorInput.addEventListener("cut", listener);
  codeEditorInput.addEventListener("delete", listener);
  codeEditorInput.addEventListener("mouseup", listener);
}


setChangeListener(codeEditorInput, function(event){
  // codeEditorInput.classList = "";
  // var savedSel = rangy.saveSelection(codeEditorInput);
  // console.log(savedSel.win.innerHTML);
  // hljs.highlightBlock(codeEditorInput);
  // rangy.restoreSelection(savedSel);
});

var codeEditorInput = document.getElementById("code-editor-input");

codeEditorInput.addEventListener('input',function(){
  // console.log('ok');
});

// Bind & handle changes on PXON VIEWER CHECKBOX
inputCodeEditorCheckbox.addEventListener( 
  'change',
  function() {
      codeEditor = document.getElementById("draw-with-words");
    if(this.checked) {
      codeEditor.style.display = "block"
    } else {
      codeEditor.style.display = "none"
    }
  }
);

// Bind & handle changes on UNDO VISUALIZER CHECKBOX
inputUndoVisualizerCheckbox.addEventListener( 
  'change', 
  function() {
    if(this.checked) {
        UNDO_VISUALIZER = true;
        var undoVisualizer = document.createElement("div");
        undoVisualizer.id = "undo-history";
        gridContainer.after(undoVisualizer);
        undoVisualizer.innerHTML = "";
        undoStack.forEach(element =>
          undoVisualizer.innerHTML += element
        );
        inputUndoVisualizerScaleContainer.style.display = "inline-block";
        inputUndoVisualizerGapContainer.style.display = "inline-block";
    } else {
      UNDO_VISUALIZER = false;
      var undoVisualizer = document.getElementById('undo-history');
      undoVisualizer.remove();
      inputUndoVisualizerScaleContainer.style.display = "none";
      inputUndoVisualizerGapContainer.style.display = "none";
    }
  }
);

// Bind  to changes on UNDO VISUALIZER SCALE
inputUndoVisualizerScale.addEventListener("input", function() {
  updateUndoVisualizerScale(inputUndoVisualizerScale.value);
}, false); 

// Handle changes to UNDO VISUALIZER SCALE
function updateUndoVisualizerScale(n){
  var n = n + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #undo-history .board{
      grid-template-rows: repeat(` + BOARD_SIZE + `, ` + n + `);
      grid-template-columns: repeat(` + BOARD_SIZE + `, ` + n + `);
    } `;   
  document.head.appendChild(style);
}

// Handle changes to UNDO VISUALIZER GAP
inputUndoVisualizerGap.addEventListener("input", function() {
  const style = document.createElement('style');
  if (inputUndoVisualizerGap.value > 0){
    style.innerHTML = `
      #undo-history .board {
          grid-gap: `  + inputUndoVisualizerGap.value + `px `  + inputUndoVisualizerGap.value + `px;
      }`;     
  }else{
    style.innerHTML = `
    #undo-history .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateUndoVisualizerScale(inputUndoVisualizerScale.value - 1);
  setTimeout(function(){ 
    updateUndoVisualizerScale(inputUndoVisualizerScale.value); 
  }, 15);
}, false); 
var timeout;

// Handle code input

var inputCodeSubmitButton = document.getElementById("submit-code-button");
inputCodeSubmitButton.addEventListener("click", function(){
  code = document.getElementsByTagName("code");
  userCode = code[0].textContent;
  
  var errorContainer = document.getElementById("code-editor-console")
  errorContainer.innerHTML = "";
  
  
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        transition: background-color .2s ease; 
    }`;     
  document.head.appendChild(style);
  
  
  try{
    window.scrollTo({ top: 0, behavior: 'smooth' });
    var timeout = true;
    setTimeout(function(){
      eval(userCode)
    },100);  
  } catch(e) {
    // console.log(e.lineNumber);
    errorContainer.innerHTML = e.message;
    console.log("something done wrong " +e.message)
  }
});

      const style2 = document.createElement('style');
      style2.innerHTML = `
        .dot {
            transition: none; 
        }`;     
      document.head.appendChild(style2);
      
//////// HANDLING UPDATES

function updateInitialDotColor(color){
  if(!color){
    color = inputInitialDotColor.value
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        --dotColor: ` + color + `;
        background-color: var(--dotColor); 
    }`;     
  // set the value
  initialDotColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (in case changed elsewhere)
  inputInitialDotColor.value = color;  
  // save state
  saveState();
  return color
}

function updateNewDrawColor(color){
  if(!color){
    color = inputNewDrawColor.value;
  }
  document.body.style.setProperty("--currentNewDrawColor", color);
  //set the value
  newDrawColor = color;
  // set the input (in case changed elsewhere)
  inputNewDrawColor.value = color;  
  // save state
  saveState();
  return color
}

function updateBackgroundColor(color){
  if(!color){
    color = inputBackgroundColor.value;
  }
  var hex = unhex(color);
  var foregroundTextColor = "#ffffff";
  if(hex.l > 0.75){
    foregroundTextColor = "#000000";
  } else{
    foregroundTextColor = "#ffffff";
  }
  
  const style = document.createElement('style');
  style.innerHTML = `
    body {
        --bgColor: ` + color + `;
        background-color: var(--bgColor);
        --textColor: ` + foregroundTextColor +`;
        color: ` + foregroundTextColor +`;
    }`;     
  // set the value
  backgroundColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (redundant if changed via input)
  inputBackgroundColor.value = color;
  // save state
  saveState();
  return color;
}      
      
      
function clearBoard() {
  window.history.pushState("object or string", "Title", "/"+window.location.href.substring(window.location.href.lastIndexOf('/') + 1).split("?")[0]);

  if(gridContainer){
    var dots = document.querySelectorAll(".dot");
    gridContainer.style.transition = "all 1s ease"
    dots.forEach(item => 
      item.style.transition = "all .6s ease"
    );
    dots.forEach(item => 
      item.style.cssText += `box-shadow: 0 0 ` + 80 + `px  var(--glowColor),
           0 0 ` + 80 + `px  var(--glowColor);`
    );
    setTimeout(function(){
      dots.forEach(item => 
        item.style.cssText += `box-shadow: 0 0 ` + 0 + `px  var(--glowColor),
             0 0 ` + 0 + `px  var(--glowColor);`
      );
      gridContainer.style.opacity = 0;
      setTimeout(function(){
        gridContainer.innerHTML = "";
        gridContainer.style.transition = "opacity .2s ease";
        gridContainer.style.transform = "scale3d(1,1,1)"
        gridContainer.style.opacity = 1;
        startup();
      }, 1000);
    }, 600);
  }
}
//////// START UP   
function startup() {
  if(gridContainer){
    gridContainer.innerHTML = "";
  }
  // loadState();
  updateInitialDotColor(initialDotColor);
  updateBackgroundColor(backgroundColor);
  updateNewDrawColor(newDrawColor);
  updatePxonViewerCheckbox(pxonViewerCheckbox);

  // CREATE BOARD
  gridContainer = document.getElementById('grid-container');
  dotBoard = document.createElement("div");
  dotBoard.className = "board board0";
  dotBoard.tabIndex = "0";
  gridContainer.appendChild(dotBoard);        
  dotCount = BOARD_SIZE * BOARD_SIZE
  
  for(y = 0; y < BOARD_SIZE; y++){
    for(x = 0; x < BOARD_SIZE; x++){            
        dot = document.createElement("div");
        dot.className = "dot";
        dot.setAttribute("x-coord", x);
        dot.setAttribute("y-coord", y);
        dotBoard.appendChild(dot);
    }
  }  
  
    
  updateDotScale(dotSize);
  updateDotRadius(dotRadius);
  updateGlowRadius(glowRadius);
  
  // ADD INITIAL STATE TO UNDO STACK
  grid = document.getElementById('grid-container');
  var gridContent = grid.innerHTML;        
  undoStack.push(gridContent);
  
  bindClicksForCurrentBoard();
  
  // Save grid
  getCurrentPixels();
  saveState();
  
  
  const queryString = new URLSearchParams(window.location.search);
  // console.log(queryString);

  if(queryString.has('instructions')){
    const urlParams = queryString.get('instructions');
    console.log("have params "+urlParams);
    userCode = de(urlParams);
    console.log("decoded: "+urlParams);

    userCode = decodeURIComponent(userCode);
    console.log("decoded again "+userCode);

    var errorContainer = document.getElementById("code-editor-console")
    errorContainer.innerHTML = "";
    var arrayLOC = userCode.split('\n');
    console.log(arrayLOC);
    window.scrollTo({ top: 0, behavior: 'smooth' });

      // avoid having looping timeouts beat each other over the head.
      // thank you Felix Kling (https://stackoverflow.com/questions/6788275/eval-and-settimeout-in-a-loop/6788386#6788386)
      (function() {
        var data = arrayLOC;
        var run = function(i) {
            setTimeout(function() {
                var entry = data[i];
                if(entry) {
                  try{
                    eval(entry)  
                  } catch(e) {
                    // console.log(e.lineNumber);
                    errorContainer.innerHTML = e.message;
                    console.log("something done wrong " +e.message)
                  }
                  run(i+1); // loop until if(entry) is false
                }
            }, 85); // timeout for each draw step
        };
        run(0);
      }());
  }
};


if(document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
  console.log("waiting…");
  callback(); 
} else {
  console.log("art time");
  document.addEventListener("DOMContentLoaded", startup());
}

// event listener for keyup
function checkTabPress(e) {
    "use strict";
    // pick passed event or global event object if passed one is empty
    e = e || event;
    var activeElement;
    if (e.keyCode == 9 && !codeEditorInputFocused) {
        activeElement = document.activeElement;

    }
}




var keyboardLeft = 37,
keyboardUp = 38,
keyboardRight = 39,
keyboardDown = 40,
keyboardTab = 9, // tab
keyboardSpace = 32,
keyboardEnter = 13,
keyboardE = 69, // erase
keyboardD = 68, // draw
keyboardH = 72, // horizontal
keyboardV = 86; // vertical
 

var activeDot;
var dots = document.querySelectorAll('#grid-container .dot');

// Keyboard input handling

// KEY DOWN
document.body.onkeydown = function(e){

  var dots = document.querySelectorAll('#grid-container .dot');
  var boardFocused = isFocused(document.querySelector('#grid-container .board'));
  var dotActive = document.activeElement.classList.contains("dot");
  var zeroIndexBoardSize = BOARD_SIZE - 1;
  var prevDot;
  
  function moveFocus(toNumber){
    if(prevDot){
      prevDot.removeAttribute("tabIndex");
    }
    dots[toNumber].setAttribute("tabIndex","0");
    dots[toNumber].focus();
    console.log("moving focus to " + toNumber + ".");
    prevDot = dots[toNumber];
  }
  
  // HANDLE D
  if(e.keyCode == keyboardD && dotActive){
    addDot(dots[activeDot], color);
  }
  
  // HANDLE E
  if(e.keyCode == keyboardE && dotActive){
    // HANDLE SPACE & ENTER  WHEN BOARD IS FOCUSED
    removeDot(dots[activeDot]);
  }
  // HANDLE h
  if(e.keyCode == keyboardH && dotActive){
    updatePixel(dots[activeDot], newDrawColor, "horizontal");
  }
  // HANDLE V
  if(e.keyCode == keyboardV && dotActive){
    updatePixel(dots[activeDot], newDrawColor, "vertical");
  }
  
  // HANDLE SPACE & ENTER  WHEN BOARD IS FOCUSED
  if(e.keyCode == keyboardSpace   && boardFocused ||
     e.keyCode == keyboardEnter && boardFocused ){
    e.preventDefault(); 
    dots[0].setAttribute("tabIndex","0");
    dots[0].focus();
    console.log("set focus to dot one");
    activeDot = 0;
  }
  // HANDLE TAB  WHEN BOARD IS FOCUSED
  if(e.keyCode == 9 && boardFocused ){
    e.preventDefault(); 
    dots[0].setAttribute("tabIndex","0");
    dots[0].focus();
    console.log("set focus to dot one");
    activeDot = 0;
  }else if (e.keyCode == 9  && codeEditorInputFocused) {
    e.preventDefault();
// 
//     var sel = document.getSelection();
//     var range = sel.getRangeAt(0);
// 
//     var tabNodeValue = '\u0009' // with 4 spaces: Array(4).join('\u00a0')
//     var tabNode = document.createTextNode(tabNodeValue);
// 
//     range.insertNode(tabNode);
// 
//     range.setStartAfter(tabNode);
//     range.setEndAfter(tabNode); 
  }
  // HANDLE SPACE & ENTER  WHEN DOT IS FOCUSED
  if(e.keyCode == keyboardSpace && document.activeElement.classList.contains("dot") ||
     e.keyCode == keyboardEnter && document.activeElement.classList.contains("dot") && !boardFocused ){
    e.preventDefault(); 
    updatePixel(dots[activeDot], newDrawColor);
  }
  // HANDLE RIGHT ARROW 
  if(e.keyCode == keyboardRight && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(activeDot < dots.length - 1){
      activeDot++;
    }
    moveFocus(activeDot);
  }
  // HANDLE LEFT ARROW 
  if(e.keyCode == keyboardLeft && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(0 < activeDot){
      activeDot--;
    }
    moveFocus(activeDot);
  }
  // HANDLE DOWN ARROW 
  if(e.keyCode == keyboardDown && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log(activeDot);
    if(activeDot < dots.length - BOARD_SIZE){
      activeDot = activeDot + BOARD_SIZE;
    }
    moveFocus(activeDot);
  }
  // HANDLE UP ARROW 
  if(e.keyCode == keyboardUp && document.activeElement.classList.contains("dot")){
    e.preventDefault(); 
    console.log("testing if " + activeDot +" is greater than " +zeroIndexBoardSize);
    if(activeDot > zeroIndexBoardSize){
      activeDot = activeDot - BOARD_SIZE;
    }
    moveFocus(activeDot);
  }
}


// KEY DOWN
document.body.onkeyup = function(e){
  
}

function handleSpaceEnterPress(e) {
    "use strict";
  // pick passed event or global event object if passed one is empty
  e = e || event;
  var activeElement;
  console.log(e.keyCode);
  if (e.keyCode == 9) {
      // Here read the active selected link.
      activeElement = document.activeElement;
      // If HTML element is an anchor <a>
      console.log(activeElement);
      if (activeElement = document.querySelector('#grid-container .board'))
          // get it's hyperlink
          console.log("it's "+ activeElement);
  }
}

var body = document.querySelector('body');
body.addEventListener('keyup', checkTabPress);

  const focusedBoard = document.querySelector('#grid-container .name');
  isFocused(focusedBoard);  

function isFocused(elem){
  if (elem === document.activeElement) {
      // console.log('Element has focus!');
      return true;
  } else {
      // console.log(`Element is not focused.`);
      return false;
  }
}
//////// BIND CLICKS TO ACTIVE BOARD PIXELS


var hPressed = false;
var vPressed = false;

document.addEventListener("keydown",function(evt) {
  if (evt.which == 72) {
    hPressed = true;
    console.log(evt.which);
  }
});
document.addEventListener("keyup",function(evt) {
  if (evt.which == 72) { 
    hPressed = false;
    console.log(evt.which);
  }
});

document.addEventListener("keydown",function(evt) {
  if (evt.which == 86) {
    vPressed = true;
    console.log(evt.which);
  }
});
document.addEventListener("keyup",function(evt) {
  if (evt.which == 86) { 
    vPressed = false;
    console.log(evt.which);
  }
});
function bindClicksForCurrentBoard(){
  
  // BIND KEYBOARD CLICKS TO DOTS
  var pressed = false;
  const dots = document.querySelectorAll(".dot");
  function keyboardShortcutComboCheck(dot){
    if(hPressed == true && vPressed == true){
      updatePixel(dot, newDrawColor, "horizontal");
      updatePixel(dot, newDrawColor, "vertical");
    } else if(hPressed == true){
      updatePixel(dot, newDrawColor, "horizontal");
    }
     else if(vPressed == true){
      updatePixel(dot, newDrawColor, "vertical");
    }else{
      updatePixel(dot, newDrawColor);
    }
  }
    
    
  Array.prototype.forEach.call(dots, function(dot, i) {
    dot.onmousedown = function(event) {
      pressed = true;
      keyboardShortcutComboCheck(dot);
      undoStackReset();
      saveState();
    };
    dot.onmouseenter = function() {
      if (pressed == true) {
        keyboardShortcutComboCheck(dot);
      }
    };
    dot.onmouseup = function() {
      pressed = false;
      updatePXON();
      undoStackAdd();
      updateUndoButton();
      saveState();
    };
    dot.onmouseout = function() {
      if (pressed == true) {
        // i don't think there's anything to cancel 
      }
    }
  });
  // In case mouse leaves board while pressed
  document.onmouseup = function() {
    pressed = false;
  };   

/// TOUCH STUFF 

  //target the container so we can track touch travel 
  dotBoard.addEventListener('touchstart', function(e){
    var target = e.target;
    pressed = true;
    if(target.classList.contains("dot")){
      updatePixel(target, newDrawColor);
    }
  }, false);
  
  dotBoard.addEventListener('touchmove', e => {
    var xPos = e.changedTouches[0].pageX;
    var yPos = e.changedTouches[0].pageY;
    // get element based on xy coordinates, draw if its a dot
    var currentlyTouched = document.elementFromPoint(xPos,yPos); 
    if(currentlyTouched.classList.contains("dot")){
      updatePixel(currentlyTouched, newDrawColor);
    }
  }, { passive: false });
  
  dotBoard.addEventListener('touchend', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
  
  dotBoard.addEventListener('touchcancel', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
}



/// COMPRESSION AND DECOMPRESSION
/// thank you dave brown https://stackoverflow.com/a/34699901
function en(c){var x='charCodeAt',b,e={},f=c.split(""),d=[],a=f[0],g=256;for(b=1;b<f.length;b++)c=f[b],null!=e[a+c]?a+=c:(d.push(1<a.length?e[a]:a[x](0)),e[a+c]=g,g++,a=c);d.push(1<a.length?e[a]:a[x](0));for(b=0;b<d.length;b++)d[b]=String.fromCharCode(d[b]);return d.join("")}

function de(b){var a,e={},d=b.split(""),c=f=d[0],g=[c],h=o=256;for(b=1;b<d.length;b++)a=d[b].charCodeAt(0),a=h>a?d[b]:e[a]?e[a]:f+c,g.push(a),c=a.charAt(0),e[o]=f+c,o++,f=a;return g.join("")}


//////// DRAW LOGIC
var timer = 65;
      // s(horizontal(1));
// UPDATE DOT ELEMENT USING ACTIVE TOOL
function updatePixel(dot, color, cmd) {
  let coords = new getCoordinateByPixel(dot);
  if (cmd){
    if(cmd == "horizontal"){
      horizontal(coords.y, color);
      instructions.innerHTML += `h(`+coords.y+`,'`+color+`');\n`
    }else if (cmd == "vertical") {
      vertical(coords.x, color);    
      instructions.innerHTML += `v(`+coords.x+`,'`+color+`');\n`;
    }
  } else if(currentTool == "erase"){
    removeDot(dot);
    instructions.innerHTML += `del(`+coords.x+`, `+coords.y+`);\n`;
  }else{
    addDot(dot, color);
    instructions.innerHTML += `add(`+coords.x+`, `+coords.y+`,'`+color+`');\n`;
  }
  timer += 65;

  
}

// UPDATE DOT AT COORDINATE USING ACTIVE TOOL
function updatePixelAtCoordinate(x, y, color) {
  let foundDot = getPixelByCoordinate(x, y);
  if(currentTool == "erase"){
    removeDot(foundDot);
    instructions.innerHTML += "removePixelAtCoordinate(" + x + ", " + y + ");";
  }else{
    addDot(foundDot, color);
  }
}

// DRAW DOT AT COORDINATE 
function addPixelAtCoordinate(x, y, color) {
  let foundDot = getPixelByCoordinate(x, y);
  addDot(foundDot, color);
}
function add(x, y, color) {
  addPixelAtCoordinate(x, y, color)
}

// ERASE DOT AT COORDINATE 
function removePixelAtCoordinate(x, y) {
  let foundDot = getPixelByCoordinate(x, y);
}
function del(x, y) {
  removePixelAtCoordinate(x, y)
}

var prevDot, prevColor;

function addDot(dot, color){
  if(!color){
    color = "var(--currentNewDrawColor)"
  }
  if (dot != prevDot || color != prevColor){
    dot.style.cssText += `--glowColor:` + color + `;--dotColor:` + color + `;background-color: var(--dotColor);z-index:99;`;
    updatePXON();
  }else{
    return false;
  }
  prevDot = dot;
  prevColor = color
}
function removeDot(dot){
  dot.style.cssText = `z-index:1;`;
}
 
 
//////// UNDO LOGIC 

function undoStackAdd(){
  undoCount += 1;
  
  // ADD A CLONE OF THE GRID TO AN ARRAY
  gridContainer.firstElementChild.className = "board board" + undoStack.length;
  var gridContent = gridContainer.innerHTML;

  undoStack.push(gridContent);
  
  // // limit stack to 50?
  // if (undoStack.length > 50) {
  //   undoStack.length = 50;
  // }
  
  var previewPane = document.getElementById('preview-pane');
  previewPane.innerHTML = undoStack[undoStack.length-1];
  
  
  if (UNDO_VISUALIZER == true){
    var undoVisualizer = document.getElementById('undo-history');
    undoVisualizer.innerHTML = "";
    undoStack.forEach(element =>
      undoVisualizer.innerHTML += element
    );
  }
}

function undoStackReset(){
  if (currentUndoSpot > 0){
    undoStack = undoStack.slice(0,currentUndoSpot);
    // console.log("sliced to: " + undoStack.length);
    undoPresses = 0;
    undoCount = 0;
    undoSize = 0;
    currentUndoSpot = 0;
  }
}

function undoStackDelete(){
  undoStackReset()
  var undoBlocks = document.querySelectorAll("#undo-history .board");
  undoBlocks.forEach(block => 
    block.remove()
  );
}

// UPDATE UNDO BUTTON THINGS ON CHANGE
function updateUndoButton(currentSpot){
  if (undoCount > 0){
    undoButton.disabled = false;
    undoButton.style.opacity = 1;
    if (currentSpot == 0){
      undoButton.disabled = true;
      undoButton.style.opacity = .5;
    };
  } else{
    undoButton.disabled = true;
    undoButton.style.opacity = .5;
  }
}


// WHEN THE UNDO BUTTON IS PRESSED
document.getElementById("undo-button").onclick = function(){
  triggerUndo();
}; 

function triggerUndo(){
  // get size of undo array
  let undoSize = undoStack.length;
  
  // count how many times button was pressed
  undoPresses += 1;
  
  // get the target undo location (and location counting from 0 lol)
  currentUndoSpot = undoSize - undoPresses;        
  currentUndoSpotFromIndex = currentUndoSpot - 1;
  
  // put desired undo into the main editor
  document.getElementById('grid-container').innerHTML = undoStack[currentUndoSpotFromIndex];
  
  // light up current item in undo stack
  if (UNDO_VISUALIZER == true){
    let getLastUndoIndex = "board" + currentUndoSpotFromIndex;
    document.querySelectorAll(".board").forEach(
      function(board) {
        if (board.classList.contains(getLastUndoIndex)){
          board.style.border = "1px solid white"
        } else{
          board.style.border = "none";
        }
      }
    )
  }
  
  updateUndoButton(currentUndoSpotFromIndex);
  
  // re-set-up bindings 
  bindClicksForCurrentBoard();
}

 
 
 
//////// PXON STUFF 


function getCurrentPixels(){
  // get all current pixel elements (.dot class <div> items) and put them in an array
  var dots = document.querySelectorAll("#grid-container .dot");
  var currentBoard = [];
  dots.forEach(dot => 
    currentBoard.push(dot)
  );
   
  //
  //  Slice that array at each row of pixels, calculated from BOARD_SIZE.
  //  Each element in gridArray will be an array containing a row worth of pixel
  //  elements. This lets us get x,y coordinates from a previously flat list.
  //
  //  prev:
  //  currentBoard[]  = [{"•","•","•","•","•","•","•","•","•"}] 
  // 
  //  now:                     x0  x1  x2  …
  //  gridArray[][] =  y0 [{[{"•","•","•",}],
  //                   y1   [{"•","•","•",}],
  //                   y2   [{"•","•","•"}]}] 
  //                   …
  // 
  for(loop = 0; loop < BOARD_SIZE; loop++){
    if(loop < 1){
      gridArray[loop] = currentBoard.slice(0, BOARD_SIZE);
    }else{
      var oldVal = (loop) * BOARD_SIZE;
      var newVal = (loop + 1) * BOARD_SIZE;
      gridArray[loop] = currentBoard.slice(oldVal, newVal);
    }
  }
  return gridArray;
}


function getCoordinateByPixel(dot) {
  this.x = dot.getAttribute("x-coord");
  this.y = dot.getAttribute("y-coord");
}

function getPixelByCoordinate(x,y){
  if( 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE){
    return gridArray[y][x];
  }else{
    console.log("coordinate (" + x + ", " + y + ") was out of bounds, setting to 0,0");
    return gridArray[0][0]
    return false;
  }
}

function updatePXON(){
  createPXON();
  pxonClean = JSON.stringify(pxon, undefined, 3)
  document.getElementById("raw").innerHTML = pxonClean;
  document.getElementById("export-pxon-textarea").innerHTML = pxonClean; 
  hasDrawn(hasDrawnSwitch)
} 

function hasDrawn(toggle){
  if(toggle == false){
    var beforeText = document.querySelectorAll(".before-drawing");
    var afterText = document.querySelectorAll(".after-drawing");  
    if(beforeText[0] && afterText[0]){
      beforeText[0].style.opacity = 0;
      beforeText[0].style.height = 0;
      afterText[0].style.display = "block";
      setTimeout(function(){
        beforeText[0].style.display = "none";
        afterText[0].style.opacity = 1;
        afterText[0].style.height = "auto";
      }, 500);
    }
    hasDrawnSwitch = true 
  }
}
// Export PXON
function createPXON(){
  var gridArray = getCurrentPixels();
  pxon = {
    exif: {
      software: "ryanwhitney.github.io/dotter",
      artist: "YOUR NAME HERE!",
      imageDescription: "DESCRIBE THE THING",
      userComment: "AND COMMENT ON IT",
      copyright: "do your name again ©",
      dateTime: new Date()
    },
    pxif: {
      pixels: []
    }
  };
  
  // Get color from each x,y coordinate
  var defaultColor = inputInitialDotColor.value
  function getpixelColor(pxArray){
    var xyPixelColor = pxArray[x][y].style.getPropertyValue('--dotColor');
    if(xyPixelColor.length > 0){
      return xyPixelColor;
    }
    else{
      return defaultColor;
    }
  }
  // From getCurrentPixels() we have an array element that contains arrays of each row of pixels. This lets us grab XY coordinates. 
  var n = 0;
  for(x = 0; x < BOARD_SIZE; x++){
    for(y = 0; y < BOARD_SIZE; y++){            
        var pixel = new Object();  
        pixel.x = (y * pxonScale); // we can agree to not talk
        pixel.y = (x * pxonScale); // about this part ok
        pixel.size = pxonScale;
        pixel.color = getpixelColor(gridArray);
        pxon.pxif.pixels[n] = pixel;
        n++;
    }
  }  
  return pxon;
}



/// WEATHER
var numbers = '7344561ed803b9';
var id = numbers;
var jsssson;
const userAction = async (lat,long) => {
  const response = await fetch('https://api.openweathermap.org/data/2.5/weather?lat='+ lat +'&lon='+ long +'&appid=' + id + '' + wnumb +')');
  const myJson = await response.json(); //extract JSON from the http response
  console.log(myJson);
  jsssson = myJson;
}
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition);
  } else {
    console.log("Geolocation is not supported by this browser.");
  }
}
function showPosition(position) {
  console.log(position.coords.latitude);
  console.log(position.coords.longitude);
  userAction(position.coords.latitude, position.coords.longitude);
  
}


/////// API 
// potential: paint/draw, erase, square, line, getColor, border, updateDrawColor,updateBackgroundColor,updateBaseColor, weather(locationRequest)
      
var instructions = document.getElementById("instructions");

function paint(x,y,color){
  if(!color){
    color = newDrawColor;
  }
  addPixelAtCoordinate(x,y,color);
  undoStackAdd();
}
function draw(x,y,color){
  paint(x,y,color);
}

// 
// let exampleSeries = [
//   {
//     "x": 5,
//     "y": 10,
//   },
//   {
//     "x": 5,
//     "y": 11,
//     "color":"red",
//   },
// ]
function drawSeries(series,color, delay){
  for(itt = 0; itt < series.length; itt++){
    let current = itt;
    if(!color){
      if(series[itt].color){
        console.log("2")
      }else{
        console.log("3")
      }
    }
    if(!delay){
      delay = 100;
    }
    let timeout = delay * itt;
    setTimeout(function(){
      paint(series[current].x,series[current].y,series[current].color);
    }, parseInt(timeout));
   
  }
}
function erase(x,y){
  removePixelAtCoordinate(x, y);
}

function s(t,f){
  if(!t){
    let t = 100;
  }
  console.log(f);
  setTimeout(function(){
    eval(f);
  },t);
};

function h(y, color){
  horizontal(y, color);
}

function horizontal(y, color){
  if(!color){
    color = newDrawColor;
  }
  for(iter = 0; iter < BOARD_SIZE; iter++){
    updatePixelAtCoordinate(iter,y,color);
  }
  undoStackAdd();
}

function v(x, color){
  vertical(x, color);
}

function vertical(x, color){
  if(!color){
    color = newDrawColor;
  }
  for(iter = 0; iter < BOARD_SIZE; iter++){
    updatePixelAtCoordinate(x,iter,color);
  }
  undoStackAdd();
}

function square(x1,y1,x2,y2,color){
  if(!color){
    color = newDrawColor;
  }
  //do a switcharoo in case latter coordinates are closer to 0,0
  if(x1 > x2){
    let oldValHolder = x1; x1 = x2; x2 = oldValHolder;
  }
  if(y1 > y2){
    let oldValHolder = y1; y1 = y2; y2 = oldValHolder;
  }
  //draw rows to fill in the square
  for(xAxis = x1; xAxis <= x2; xAxis++){
    for(yAxis = y1; yAxis <= y2; yAxis++){
      // console.log("attempting to draw at (" + xAxis + ", " + yAxis + ")");
      updatePixelAtCoordinate(xAxis, yAxis, color);
    }
  }
  undoStackAdd();
}

function line(x1,y1,x2,y2,color){

};


//// PXON TO SVG

// Render a PXON document to SVG
// https://github.com/pxon/pxon-schema

function renderSVG(pxon, container) {

  // Remove existing
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
  
  
  const previewToPixelRatio = pxonScale / dotSize;
  var extraGap = (inputGridGapSize.value * previewToPixelRatio * (BOARD_SIZE + 4));
  console.log(extraGap);

  const svgns = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS (svgns, 'svg');
  svg.setAttribute('xmlns', svgns);
  svg.setAttribute('version', '1.1');
  svg.setAttribute('width', BOARD_SIZE * pxonScale + extraGap -0.5);
  svg.setAttribute('height', BOARD_SIZE * pxonScale + extraGap -0.5);

  const {
    pxif: { pixels }
  } = JSON.parse(pxon);
  
  const rx = (dotRadius * previewToPixelRatio);
  const background = document.createElementNS(svgns, 'rect');
  background.setAttribute('x', 0);
  background.setAttribute('y', 0);
  background.setAttribute('rx', (rx*2));
  background.setAttribute('width', BOARD_SIZE * pxonScale + extraGap -0.5);
  background.setAttribute('height', BOARD_SIZE * pxonScale + extraGap -0.5);
  background.setAttribute('fill', backgroundColor);
  
  svg.appendChild(background);

  var gridSpacerX = 1;
  var gridSpacerY = 1;
  const gridGap = (inputGridGapSize.value * previewToPixelRatio);
  
  pixels.forEach((p) => {
    const ps = p.size;
    const pc = p.color;

    // Normalise x/y values to closest grid coordinate
    
    var px = ps * Math.ceil(p.x/ps);
    var py = ps * Math.ceil(p.y/ps);
    
    px = parseFloat(px) + (gridSpacerX * gridGap + 2);
    py = parseFloat(py) + (gridSpacerY * gridGap + 2);
    
    // because this is setting down each pixel one at a time,
    // left to right and top to bottom, we need to calculate
    // when each new row to create margins via offsetting x,y
    if(gridSpacerX == (BOARD_SIZE)){
      gridSpacerX = 1;
      gridSpacerY++;
    }else{
      gridSpacerX++;
    }
    
   
    
    
    
    const pixel = document.createElementNS(svgns, 'rect');
    pixel.setAttribute('x', px);
    pixel.setAttribute('y', py);
    pixel.setAttribute('rx', rx);
    pixel.setAttribute('width', ps);
    pixel.setAttribute('height', ps);
    pixel.setAttribute('fill', pc);
    svg.appendChild(pixel);
    
  });
  container.appendChild(svg);
  document.getElementById('export-svg-textarea').value = svg.outerHTML;
}

function renderSVGfromExportWindow(){
  var oldSvg = document.getElementById('svg-output');
  if(oldSvg){
    oldSvg.remove();
  }
  const input = document.getElementById('export-pxon-textarea');
  const output = document.createElement('div');
  output.setAttribute('id', 'svg-output');
  
  document.getElementById('svg-preview').appendChild(output);
  
  // input.oninput = function(e) {
    renderSVG(input.value, output);
  // }
  // Trigger initial render
  // input.dispatchEvent(new Event('input'));
}


document.getElementById('download-svg').addEventListener("click",function(){
  let theSvg = document.getElementById('svg-output').innerHTML;
  download(theSvg, "the-good-drawing.svg","svg")
})
document.getElementById('download-pxon').addEventListener("click",function(){
  let thePxon = document.getElementById('export-pxon-textarea').innerHTML;
  download(thePxon, "the-good-drawing.pxon","pxon")
})

// DOWNLOAD thank u https://stackoverflow.com/a/30832210
function download(data, filename, type) {
  var file = new Blob([data], {type: type});
  if (window.navigator.msSaveOrOpenBlob) // IE10+
      window.navigator.msSaveOrOpenBlob(file, filename);
  else { // Others
      var a = document.createElement("a"),
              url = URL.createObjectURL(file);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function() {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);  
      }, 0); 
  }
}




const moreRainbowCode = `function moreRainbow(){
  for(i=0;i<16;i++){
    // multiply the hue each iteration, using 20
    // keeps it under the max value for hsv()
    let color = "hsl("+ i*20 +",65%,70%)";
    vertical(i, color);
  };
  setTimeout(function(){
    for(i=0;i<16;i++){
      let color = "hsl("+ i*20 +",65%,70%)";
      horizontal(i, color);
    }
    setTimeout(function(){
      moreRainbow();
    },500);
  },500);
}
moreRainbow();`;

    </script>
  </body>
</html>
