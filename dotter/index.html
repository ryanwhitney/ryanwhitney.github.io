<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name='viewport' 
 content='width=device-width, initial-scale=1.0, maximum-scale=1.0, 
 user-scalable=0'>
     <title>dotter</title>
    
    <style>
    
    /* CSS files add styling rules to your content */
    *{
      font-family:  SFMono-Regular, "SFMono-Regular", SFMono, Menlo,
        Monaco, Consolas,"Liberation Mono","Courier New", monospace;
        box-sizing: border-box;
    }
    body {
      font-family: helvetica, arial, sans-serif;
      height: 100vh;
      margin: 0;
      font-size: 12px;
      background-color: #000;
      transition: background-color .3s ease;
      padding-bottom: 160px;
      --textColor: white;
    }
    p{
      line-height: 1.5;
    }
    #export-window{
      z-index: 9999;
      width: 80%;
      height: 80%;
      display: flex;
      position: fixed;
      top: 50%;
      left: 50%;
      /* bring your own prefixes */
      transform: translate(-50%, -50%);
      background-color: var(--bgColor);
    }
    .overlay{
      height: 100%;
      width: 100%;
      position: fixed; /* Stay in place */
      z-index: 999;
      left: 0;
      top: 0;
      background-color: var(--bgColor);
      filter: brightness(0.2);
      opacity: .4;
    }
    #pxon-scale{
      position: absolute;
      right: 85px;
      top: 7.5px;
    }
    #copy-pxon{
      position: absolute;
      right: 5px;
      top: 5px;
    }
    #pxon-panel{
      display: flex;
      flex-direction: column;
      line-break: normal;
      float: right;
      width: 40%;
      height: 100vh;
      display: none;
      z-index: 1;
      color: var(--textColor);
      transition: width .2s ease-in-out;
    }
    #pxon-panel .pxon-panel-top{
      height: 40px;
    }
    #raw{
      overflow: hidden;
      overflow-y: scroll;
      background: none;
      border: none;
      height: 100%;
      color: var(--textColor);
    }
    input,label, button{
      text-transform: lowercase;
      color: var(--textColor);
    }
    .tools{
      display: flex;
      margin: 20px;
      padding-bottom: 10px;
      justify-content: space-around;
    }
    #grid-container{
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
       -khtml-user-select: none; /* Konqueror HTML */
         -moz-user-select: none; /* Old versions of Firefox */
          -ms-user-select: none; /* Internet Explorer/Edge */
              user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
    }
    #grid-container .board{
      margin: auto;
      touch-action: none;
    }
    .board-container{
      display: flex;
      justify-content:space-around;
      align-content: center;
    }
    .board{
      display: grid;
      grid-gap: 3px 3px;
      grid-template-rows: 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px;
      grid-template-columns: 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px 20px;
    }
    .dot{
      background-color: #19181A;
    }  
    input[type=color]{
      /* border: none;
      background-color: transparent; */
    }
    input[type=number]{
      background-color:transparent;
    }
    input[type=submit]{
      margin-top: 10px;
      background-color:transparent;
      border-width: 1px;
      border-color: var(--currentNewDrawColor) !important;
      float: right;
      color: var(--textColor);
    }
    #draw-with-words{
      margin: 40px auto 20px;
      width: 364px;
      color: var(--textColor);
    }
    code{
      width: 364px;
      min-height: 150px;
      border: 1px solid var(--currentNewDrawColor);
      line-height: 1.5;
      border-radius: 6px;
      display: block;
      margin: auto;
      padding: 20px;
      text-align: left;  
      text-transform: unset !important;    
    }
    code div::before{
      content: ">";
      margin-left:-12px;
      padding-right: 5px;
    }
    code * {
      color: var(--currentNewDrawColor) !important;
      text-align: left;      
      text-transform: unset !important;
    }
    span.code{
      color: var(--currentNewDrawColor);
    }    
    button{
      background-color: black;
      border-width: 1px;
      color: var(--textColor);
    }
    #more-tools{
      display: flex;
      flex-direction: column;
      position: absolute;
      bottom: 10px;
      left: 10px;
    }
    #more-tools input,
    #more-tools label{
      background-color: rgba(0,0,0,.2);
      
    }
    #undo-visualizer * {
      display: inline-block;
    }
    #undo-visualizer #undo-tile-scale, 
    #undo-visualizer #undo-tile-gap{
      display: none;
    }
    #undo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #redo-button{
      opacity: .5;
      transition: opacity .1s ease-in-out;
    }
    #undo-history:first-child { margin-top: auto }
    #undo-history{
      display: flex;
      flex-direction: row-reverse;
      justify-content:  flex-end;
      flex-wrap: nowrap;
      white-space: nowrap;
      margin-top: 20px;
      border: 1px solid rgba(255,255,255,.2);
      padding: 10px;
      max-width: 95%;
      overflow-x: scroll;
      margin: 30px auto 0;
    }
    #undo-history .board{
      grid-gap: 0 0;
      margin-right: 10px;
      grid-template-rows: 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px;
      grid-template-columns: 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px 2px;
    }
    #undo-history .dot{

    }
    </style>
  </head>  
  <body>
    <!-- <div id="export-window">
      <h2>Export your dots to PXON or SVG</h2>
    </div>
    <div class="overlay"></div> -->
    <div id="pxon-panel">
      <div class="pxon-panel-top">
        <div id="pxon-scale">
          <label for="select-pxon-scale">pxon scale:</label>
          <input type="number" id="select-pxon-scale" value="1" style="width:40px;"/>
        </div>
        <button id="copy-pxon">copy</button>
      </div>
      <textarea id="raw"></textarea>
    </div>
    <div class="tools">
      <div id="initial-dot-color-select">
        <label for="select-color">Initial Dot Color</label>
        <input type="color" id="initial-dot-color-selected" name="select-initial-dot-color"
           value="#1f1f1f">
      </div>
      <div id="color-select">
        <label for="select-color">New Dot Color</label>
        <input type="color" id="color-selected" name="select-color"
           value="#FFA57D">
      </div>
      <div id="background-select">
        <label for="select-color">Background Color</label>
        <input type="color" id="background-color-selected" name="select-background-color"
           value="#19181A">
      </div>
    </div>
    <div class="tools">
      <div id="select-dot-size" style="width:80px;">
        <label for="select-dot-size">dot size</label>
        <input type="number" id="dot-size" name="select-dot-size"
           value="20" style="width:80px;">
      </div>
      <div id="select-dot-radius-amount" style="width:80px;">
        <label for="select-dot-radius-amount">dot radius</label>
        <input type="number" id="dot-radius-amount" name="select-dot-radius-amount"
           value="3" style="width:80px;">
      </div>
      <div id="select-grid-gap-size" style="width:80px;">
        <label for="select-grid-gap-size">grid gap</label>
        <input type="number" id="grid-gap-size" name="select-grid-gap-size"
           value="3" style="width:80px;">
      </div>
      <div id="select-glow-amount" style="width:60px;">
        <label for="select-glow-amount">glow</label>
        <input type="number" id="glow-amount" name="select-glow-amount"
           value="0" style="width:40px;">
      </div>
      <div id="select-draw-erase">
        <input type="radio" id="select-draw-radio" name="draw-erase-radio" value="draw" / checked>
        <label for="select-draw-radio">draw</label><br/>
        <input type="radio" id="select-erase-radio" name="draw-erase-radio" value="erase" />
        <label for="select-erase-radio">erase</label>
      </div>
      <div class="undo">
        <button id="undo-button" disabled>undo</button>
      </div>
      <div class="redo">
        <button id="redo-button" disabled>redo</button>
      </div>
    </div>
    <div id="grid-container" class="board-container">
    </div>
    <div id="more-tools">
      <div class="check">
        <input type="checkbox" id="hide-checkbox" name="hide">
        <label for="hide">hide</label>
      </div>
      <div class="check experiment">
        <input type="checkbox" id="code-editor-checkbox" name="code-editor" checked>
        <label for="code-editor">draw with words</label>
      </div>
      <div class="check experiment">
        <input type="checkbox" id="enable-pxon-viewer" name="enable-pxon-viewer">
        <label for="enable-pxon-viewer">PXON viewer</label>
      </div>
      <div id="undo-visualizer" class="check experiment">
        <input type="checkbox" id="enable-undo-visualizer" name="enable-undo-visualizer">
        <label for="enable-undo-visualizer">undo stack visualizer</label>
        <div id="undo-tile-scale">
          <span>(pls disable if slow)</span>
          <label for="select-undo-tile-scale">&nbsp;&nbsp; scale</label>
          <input type="number" id="select-undo-tile-scale" name="select-undo-tile-scale" value="2" style="width:40px;">
        </div>
        <div id="undo-tile-gap">
          <label for="select-undo-tile-gap">&nbsp;&nbsp; gap</label>
          <input type="number" id="select-undo-tile-gap" name="select-undo-tile-gap" value="0" style="width:40px;">
        </div>
      </div>
    </div>
    <div id="draw-with-words">
        <p><span style="font-size:12px">⚠️</span> heads up this is just javascript</p>
        <p>but also with extra functions available.</p><p>like <span class="code">paint(<b>x</b>,<b>y</b>);</span></p><p>just replace <b>x</b> and <b>y</b> with coordinates. (note: the board is 16x16 and begins at 0,0!)</p>
        <code name="code-editor" id="code-editor" contenteditable="true" autocapitalize="off" autocomplete="off" spellcheck="false">
          <span class="comment">// try writing paint(0,5);</span>
          <br/>
        <div></div>
      </code>
      <input id="submit-code-button" type="submit" value="run the code" title="run the code, do it" />
    </div>
    <script>
    
    


var gridContainer,
  undoStack = [],
  gridArray = [],
  gridContainer = document.getElementById('grid-container'),
  undoPresses = 0,
  undoCount = 0,
  undoButton = document.getElementById("undo-button"),
  BOARD_SIZE = 16,
  dotBoard,
  dotCount,
  currentTool,
  pxonScale = 10,
  dot,
  i,
  color,
  undoSize,
  currentUndoSpot,
  currentUndoSpotFromIndex,
  UNDO_VISUALIZER = false; 

//////// SET UP OPTIONS + USER INPUTS

var inputInitialDotColor = document.getElementById("initial-dot-color-selected"),
  inputNewDrawColor = document.getElementById("color-selected"),
  inputBackgroundColor = document.getElementById("background-color-selected"),
  inputDotSize = document.getElementById("dot-size"),
  inputDotRadius = document.getElementById("dot-radius-amount"),
  inputGridGapSize = document.getElementById("grid-gap-size"),
  inputGlowRadius = document.getElementById("glow-amount"),
  inputDrawEraseRadio = document.getElementById("draw"),
  inputHideCheckbox = document.getElementById("hide-checkbox"),
  inputPxonViewerCheckbox = document.querySelector("input[name=enable-pxon-viewer]"),
  inputPxonScale = document.getElementById("pxon-scale")
  inputCodeEditorCheckbox = document.getElementById("code-editor-checkbox")
  inputUndoVisualizerCheckbox = document.querySelector("input[name=enable-undo-visualizer]"),
  inputUndoVisualizerScaleContainer = document.getElementById("undo-tile-scale"),
  inputUndoVisualizerScale = document.getElementById("select-undo-tile-scale"),
  inputUndoVisualizerGapContainer = document.getElementById("undo-tile-gap"),
  inputUndoVisualizerGap = document.getElementById("select-undo-tile-gap");

function deleteBoard() {
  if (confirm("Are you sure you want to delete this board? It…cannot be undone.")) {
    var board = document.querySelectorAll("#grid-container .board");
    board[0].remove();
    startup();
  } else {
    return false;
  }
}

var initialDotColor,
  newDrawColor,
  backgroundColor,
  dotSize,
  dotRadius,
  gridGapSize,
  glowRadius,
  hideCheckbox,
  pxonViewerCheckbox,
  codeEditorCheckbox,
  undoVisualizerCheckbox,
  undoVisualizerScale,
  undoVisualizerGap;
  
  var defaultOptions = {
    initialDotColor: "#1f1f1f",
    newDrawColor: "#ffa57d",
    backgroundColor: "#19181a",
    dotSize: 20,
    dotRadius: 3,
    gridGapSize: 3,
    glowRadius: 0,
    hideCheckbox: false,
    pxonViewerCheckbox: false,
    pxonScale: 1,
    codeEditorCheckbox: true,
    undoVisualizerCheckbox: false,
    undoVisualizerScale: 2,
    undoVisualizerGap: 0,
    currentTool: "draw"
  }

function getState(){
  initialDotColor = localStorage.getItem("initialDotColor") | inputInitialDotColor.value;
  newDrawColor = inputNewDrawColor.value;
  backgroundColor = localStorage.getItem("backgroundColor") | inputBackgroundColor.value;
  dotSize = inputDotSize.value;
  dotRadius = inputDotRadius.value;
  gridGapSize = inputGridGapSize.value;
  hideCheckbox = inputHideCheckbox.checked;
  glowRadius = inputGlowRadius.value;
  pxonViewerCheckbox = inputPxonViewerCheckbox.checked;
  codeEditorCheckbox = inputCodeEditorCheckbox.checked;
  undoVisualizerCheckbox = inputUndoVisualizerCheckbox.checked;
  undoVisualizerScale = inputUndoVisualizerScale.value;
  undoVisualizerGap = inputUndoVisualizerGap.value;
}


function loadState(){
  if (typeof(Storage) !== "undefined") {
    initialDotColor = localStorage.getItem("initialDotColor");
    newDrawColor = localStorage.getItem("newDrawColor");
    backgroundColor = localStorage.getItem("backgroundColor");
    dotSize = localStorage.getItem("dotSize");
    dotRadius = localStorage.getItem("dotRadius");
    gridGapSize = localStorage.getItem("gridGapSize");
    glowRadius = localStorage.getItem("glowRadius");
    hideCheckbox = localStorage.getItem("hideCheckbox");
    codeEditorCheckbox = localStorage.getItem("codeEditorCheckbox");
    pxonViewerCheckbox = localStorage.getItem("pxonViewerCheckbox");
    undoVisualizerCheckbox = localStorage.getItem("undoVisualizerCheckbox");
    undoVisualizerScale = localStorage.getItem("undoVisualizerScale");
    undoVisualizerGap = localStorage.getItem("undoVisualizerGap");
  } else {
    // no localstorage..
  }
  
}

function applyState(){
  updateInitialDotColor(initialDotColor)
}

function saveState(){
  if (typeof(Storage) !== "undefined") {
    localStorage.setItem("initialDotColor", initialDotColor);
    localStorage.setItem("newDrawColor", newDrawColor);
    localStorage.setItem("backgroundColor", backgroundColor);
    localStorage.setItem("dotSize", dotSize);
    localStorage.setItem("dotRadius", dotRadius);
    localStorage.setItem("gridGapSize", gridGapSize);
    localStorage.setItem("glowRadius", glowRadius);
    localStorage.setItem("hideCheckbox", hideCheckbox);
    localStorage.setItem("codeEditorCheckbox", codeEditorCheckbox);
    localStorage.setItem("pxonViewerCheckbox", pxonViewerCheckbox);
    localStorage.setItem("undoVisualizerCheckbox", undoVisualizerCheckbox);
    localStorage.setItem("undoVisualizerScale", undoVisualizerScale);
    localStorage.setItem("undoVisualizerGap", undoVisualizerGap);  
  } else {
    // no localstorage..
  }
  
}

// hex to hsl copyright uhhh stack overflow
function unhex(hex){
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  r = parseInt(result[1], 16);
  g = parseInt(result[2], 16);
  b = parseInt(result[3], 16);
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if(max == min){
    h = s = 0; // achromatic
  }else{
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch(max){
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  var HSL = new Object();
  HSL['h']=h;
  HSL['s']=s;
  HSL['l']=l;
  return HSL;
}

// Bind to input changes on INITIAL dot color  
inputInitialDotColor.addEventListener("input", function() {
  updateInitialDotColor(inputInitialDotColor.value);
}, false); 
   
// Bind to input changes on NEW DRAW color  
inputNewDrawColor.addEventListener("input", function() {
  updateNewDrawColor(inputNewDrawColor.value);
}, false); 
      
// Bind to input changes on BACKGROUND color 
inputBackgroundColor.addEventListener("input", function() {
  updateBackgroundColor(inputBackgroundColor.value);
}, false); 

// Bind to input changes on DOT RADIUS
inputDotRadius.addEventListener("input", function() {
  updateDotRadius(inputDotRadius.value);
}, false); 

function updateDotRadius(amount){
  if(!amount){
    amount = 3;
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        border-radius:` + inputDotRadius.value + `px;
    }`;     
  document.head.appendChild(style);
  // update variable
  dotRadius = amount;
  // update input value
  inputDotRadius.value = amount;
  // save state
  saveState();
}

// Bind to input changes on DOT SIZE
inputDotSize.addEventListener("input", function() {
  updateDotScale(inputDotSize.value);
}, false); 

// Handle changes to DOT SIZE
function updateDotScale(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 20;
  }
  var n = sizeInPx + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #grid-container .board{
      grid-template-rows:` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + `;
      grid-template-columns:` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + `;
    } `;   
  document.head.appendChild(style);
  // update variable
  dotSize = sizeInPx;
  // update input value
  inputDotSize.value = sizeInPx;
  // save state
  saveState();
}

// Bind to input changes on GRID GAP 
inputGridGapSize.addEventListener("input", function() {
  updateGridGapSize(inputGridGapSize.value);
}, false);

function updateGridGapSize(sizeInPx){
  if(!sizeInPx){
    sizeInPx = 3;
  }
  const style = document.createElement('style');
  if (sizeInPx > 0){
    style.innerHTML = `
      #grid-container .board {
          grid-gap: `  + sizeInPx + `px `  + sizeInPx + `px;
      }`;     
  }else{
    style.innerHTML = `
    #grid-container .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateDotScale(dotSize - 1);
  setTimeout(function(){ 
    updateDotScale(dotSize + 1); 
  }, 15);
  // update variable
  gridGapSize = amount;
  // update input value
  inputGridGapSize.value = amount;
  // save state
  saveState();
}

// Bind and handle input changes on GLOW AMOUNT
inputGlowRadius.addEventListener("input", function() {
  updateGlowRadius(inputGlowRadius.value);
}, false); 

// Handle changes to GLOW AMOUNT
function updateGlowRadius(amount){
  if(!amount){
    amount = 0;
  }
  var dots = document.querySelectorAll(".dot");
  dots.forEach(item => 
    item.style.cssText += `box-shadow: 0 0 ` + amount + `px  var(--glowColor),
         0 0 ` + amount + `px  var(--glowColor);`
  );
  // update variable
  glowRadius = amount;
  // update input value
  inputGlowRadius.value = amount;
  // save state
  saveState();
}

// Bind to changes on DRAW / ERASE RADIO
var drawEraseRadios = document.querySelectorAll('input[name=draw-erase-radio]');
for (var i = 0; i < drawEraseRadios.length; i++) {
  drawEraseRadios[i].addEventListener('change', function() {
      if(this.value == "draw"){
        currentTool = "draw";
      } else{
        currentTool = "erase";
      }
  });
}

// Bind & handle changes on PXON VIEWER CHECKBOX
inputPxonViewerCheckbox.addEventListener( 
  'change',
  function() {
    updatePxonViewerCheckbox(this);
  }
);


function updatePxonViewerCheckbox(input){
  pxonContainer = document.getElementById("pxon-panel");
  if(input){
    if(input.checked) {
      pxonContainer.style.display = "flex";
      pxonContainer.style.width = "40%";
      inputPxonViewerCheckbox.checked = input.checked;
    } else {
      pxonContainer.style.display = "none";
      pxonContainer.style.width = "0";
      inputPxonViewerCheckbox.checked = input.checked;
    }
  }else{
    pxonContainer.style.display = "none";
    pxonContainer.style.width = "0";
    inputPxonViewerCheckbox.checked = false;
  }  
}

// Set up copy pxon button
copyPxonButton = document.getElementById("copy-pxon");
copyPxonButton.addEventListener("click", function(){
  pxonOutputPre = document.getElementById("raw");
  var copiedPxon = pxonOutputPre;
  copiedPxon.focus();
  copiedPxon.select();
  try {
    let successful = document.execCommand('copy');
    let msg = successful ? 'successful' : 'unsuccessful';
    copyPxonButton.innerText = "successfully copied!";
    setTimeout(function(){
      copyPxonButton.innerText = "copy again";
    }, 1500);
  } catch(err) {
    alert('failed to copy. ☹️ … ' + err);
  }

})

// Bind & handle changes on PXON VIEWER CHECKBOX
inputHideCheckbox.addEventListener( 
  'change',
  function() {
    var otherCheckBoxes = document.querySelectorAll("#more-tools .experiment");
    if(this.checked) {
      otherCheckBoxes.forEach(element =>
        element.style.display = "none"
      );
    } else {
      otherCheckBoxes.forEach(element =>
        element.style.display = "block"
      );
    }
      
      
  }
);

// Bind & handle changes on PXON VIEWER CHECKBOX
inputCodeEditorCheckbox.addEventListener( 
  'change',
  function() {
      codeEditor = document.getElementById("draw-with-words");
    if(this.checked) {
      codeEditor.style.display = "block"
    } else {
      codeEditor.style.display = "none"
    }
  }
);

// Bind & handle changes on UNDO VISUALIZER CHECKBOX
inputUndoVisualizerCheckbox.addEventListener( 
  'change', 
  function() {
    if(this.checked) {
        UNDO_VISUALIZER = true;
        var undoVisualizer = document.createElement("div");
        undoVisualizer.id = "undo-history";
        gridContainer.after(undoVisualizer);
        undoVisualizer.innerHTML = "";
        undoStack.forEach(element =>
          undoVisualizer.innerHTML += element
        );
        inputUndoVisualizerScaleContainer.style.display = "inline-block";
        inputUndoVisualizerGapContainer.style.display = "inline-block";
    } else {
      UNDO_VISUALIZER = false;
      var undoVisualizer = document.getElementById('undo-history');
      undoVisualizer.remove();
      inputUndoVisualizerScaleContainer.style.display = "none";
      inputUndoVisualizerGapContainer.style.display = "none";
    }
  }
);

// Bind  to changes on UNDO VISUALIZER SCALE
inputUndoVisualizerScale.addEventListener("input", function() {
  updateUndoVisualizerScale(inputUndoVisualizerScale.value);
}, false); 

// Handle changes to UNDO VISUALIZER SCALE
function updateUndoVisualizerScale(n){
  var n = n + "px"; 
  const style = document.createElement('style');
  style.innerHTML = `
    #undo-history .board{
      grid-template-rows:` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + `;
      grid-template-columns:` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + n + ` ` + `;
    } `;   
  document.head.appendChild(style);
}

// Handle changes to UNDO VISUALIZER SCALE
inputUndoVisualizerGap.addEventListener("input", function() {
  const style = document.createElement('style');
  if (inputUndoVisualizerGap.value > 0){
    style.innerHTML = `
      #undo-history .board {
          grid-gap: `  + inputUndoVisualizerGap.value + `px `  + inputUndoVisualizerGap.value + `px;
      }`;     
  }else{
    style.innerHTML = `
    #undo-history .board {
        grid-gap: 0 0;
    }`; 
  }
  document.head.appendChild(style);
  
  // scale must be changed to recalculate grid-gap, or something. it seems to require this.
  updateUndoVisualizerScale(inputUndoVisualizerScale.value - 1);
  setTimeout(function(){ 
    updateUndoVisualizerScale(inputUndoVisualizerScale.value); 
  }, 15);
}, false); 


// Handle code input

var inputCodeSubmitButton = document.getElementById("submit-code-button");
inputCodeSubmitButton.addEventListener("click", function(){
  code = document.getElementsByTagName("code");
  console.log(code[0].textContent);
  userCode = code[0].textContent;
  console.log(userCode);
  eval(userCode);
});
      
//////// HANDLING UPDATES

function updateInitialDotColor(color){
  if(!color){
    color = inputInitialDotColor.value
  }
  const style = document.createElement('style');
  style.innerHTML = `
    .dot {
        --dotColor: ` + color + `;
        background-color: var(--dotColor); 
    }`;     
  // set the value
  initialDotColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (in case changed elsewhere)
  inputInitialDotColor.value = color;  
  // save state
  saveState();
  return color
}

function updateNewDrawColor(color){
  if(!color){
    color = inputNewDrawColor.value;
  }
  document.body.style.setProperty("--currentNewDrawColor", color);
  //set the value
  newDrawColor = color;
  // set the input (in case changed elsewhere)
  inputNewDrawColor.value = color;  
  // save state
  saveState();
  return color
}

function updateBackgroundColor(color){
  if(!color){
    color = inputBackgroundColor.value;
  }
  var hex = unhex(color);
  var foregroundTextColor = "#ffffff";
  if(hex.l > 0.75){
    foregroundTextColor = "#000000";
  } else{
    foregroundTextColor = "#ffffff";
  }
  
  const style = document.createElement('style');
  style.innerHTML = `
    body {
        --bgColor: ` + color + `;
        background-color: var(--bgColor);
        --textColor: ` + foregroundTextColor +`;
        color: ` + foregroundTextColor +`;
    }`;     
  // set the value
  backgroundColor = color;
  // append the style to the DOM in <head> section
  document.head.appendChild(style);
  // set the input (redundant if changed via input)
  inputBackgroundColor.value = color;
  // save state
  saveState();
  return color;
}      
      
//////// START UP   
function startup() {
  // loadState();
  updateInitialDotColor(initialDotColor);
  updateBackgroundColor(backgroundColor);
  updateNewDrawColor(newDrawColor);
  updatePxonViewerCheckbox(pxonViewerCheckbox);

  // CREATE BOARD
  gridContainer = document.getElementById('grid-container');
  dotBoard = document.createElement("div");
  dotBoard.className = "board board0";
  gridContainer.appendChild(dotBoard);        
  dotCount = BOARD_SIZE * BOARD_SIZE
  for (i = 0; i<dotCount; i++) {
    dot = dot+i;
    dot = document.createElement("div");
    dot.className = "dot";
    dotBoard.appendChild(dot);
  }
  
  
  
  updateDotScale(dotSize);
  updateDotRadius(dotRadius);
  updateGlowRadius(glowRadius);
  
  
  // ADD INITIAL STATE TO UNDO STACK
  grid = document.getElementById('grid-container');
  var gridContent = grid.innerHTML;        
  undoStack.push(gridContent);
  
  bindClicksForCurrentBoard();
  
  // Save grid
  getCurrentPixels();
  saveState();

};


if(document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
  console.log("waiting…");
  callback(); 
} else {
  console.log("art time");
  document.addEventListener("DOMContentLoaded", startup());
}

      
//////// BIND CLICKS TO ACTIVE BOARD PIXELS

function bindClicksForCurrentBoard(){
  
  // BIND KEYBOARD CLICKS TO DOTS
  var pressed = false;
  const dots = document.querySelectorAll(".dot");
    
  Array.prototype.forEach.call(dots, function(dot, i) {
    dot.onmousedown = function() {
      pressed = true;
      updatePixel(dot, newDrawColor);
      undoStackReset();
      saveState();
    };
    dot.onmouseenter = function() {
      if (pressed == true) {
        updatePixel(dot, newDrawColor);
      }
    };
    dot.onmouseup = function() {
      pressed = false;
      updatePXON()
      undoStackAdd();
      updateUndoButton();
      saveState();
    };
    dot.onmouseout = function() {
      if (pressed == true) {
        // i don't think there's anything to cancel 
      }
    }
  });
  // In case mouse leaves board while pressed
  document.onmouseup = function() {
    pressed = false;
  };   

/// TOUCH STUFF 

  //target the container so we can track touch travel 
  dotBoard.addEventListener('touchstart', function(e){
    var target = e.target;
    pressed = true;
    if(target.classList.contains("dot")){
      updatePixel(target, newDrawColor);
    }
  }, false);
  
  dotBoard.addEventListener('touchmove', e => {
    var xPos = e.changedTouches[0].pageX;
    var yPos = e.changedTouches[0].pageY;
    // get element based on xy coordinates, draw if its a dot
    var currentlyTouched = document.elementFromPoint(xPos,yPos); 
    if(currentlyTouched.classList.contains("dot")){
      updatePixel(currentlyTouched, newDrawColor);
    }
  }, { passive: false });
  
  dotBoard.addEventListener('touchend', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
  
  dotBoard.addEventListener('touchcancel', e => {
    pressed = false;
    updatePXON()
    undoStackAdd();
    updateUndoButton();
    saveState();
  }, { passive: false });
}

      
//////// DRAW LOGIC
      
// WHAT HAPPENS WHEN A DOT IS CLICKED
function updatePixel(dot, color) {
  if(currentTool == "erase"){
    erase(dot, color);
  }else{
    draw(dot, color);
  }
}

var prevDot, prevColor;

function draw(dot, color){
  if (dot != prevDot || color != prevColor){
    dot.style.cssText += `--glowColor:` + color + `;--dotColor:` + color + `;background-color: var(--dotColor);z-index:99;`;
    updatePXON();
  }else{
    console.log("same dot");
    return false;
  }
  prevDot = dot;
  prevColor = color
}
function erase(dot, color){
  dot.style.cssText = `z-index:1;`;
}
 
 
//////// UNDO LOGIC 

function undoStackAdd(){
  undoCount += 1;
  // console.log("undocount: " + undoCount);
  
  // ADD A CLONE OF THE GRID TO AN ARRAY
  gridContainer.firstElementChild.className = "board board" + undoStack.length;
  var gridContent = gridContainer.innerHTML;

  undoStack.push(gridContent);
  
  // // limit stack to 50?
  // if (undoStack.length > 50) {
  //   undoStack.length = 50;
  // }
  if (UNDO_VISUALIZER == true){
    var undoVisualizer = document.getElementById('undo-history');
    undoVisualizer.innerHTML = "";
    undoStack.forEach(element =>
      undoVisualizer.innerHTML += element
    );
  }
}

function undoStackReset(){
  if (currentUndoSpot > 0){
    undoStack = undoStack.slice(0,currentUndoSpot);
    // console.log("sliced to: " + undoStack.length);
    undoPresses = 0;
    undoCount = 0;
    undoSize = 0;
    currentUndoSpot = 0;
  }
}

function undoStackDelete(){
  undoStackReset()
  var undoBlocks = document.querySelectorAll("#undo-history .board");
  undoBlocks.forEach(block => 
    block.remove()
  );
}

// UPDATE UNDO BUTTON THINGS ON CHANGE
function updateUndoButton(currentSpot){
  if (undoCount > 0){
    undoButton.disabled = false;
    undoButton.style.opacity = 1;
    if (currentSpot == 0){
      undoButton.disabled = true;
      undoButton.style.opacity = .5;
    };
  } else{
    undoButton.disabled = true;
    undoButton.style.opacity = .5;
  }
}

// WHEN THE UNDO BUTTON IS PRESSED
document.getElementById("undo-button").onclick = function(){
  
  // get size of undo array
  let undoSize = undoStack.length;
  
  // count how many times button was pressed
  undoPresses += 1;
  
  // get the target undo location (and location counting from 0 lol)
  currentUndoSpot = undoSize - undoPresses;        
  currentUndoSpotFromIndex = currentUndoSpot - 1;
  
  // put desired undo into the main editor
  document.getElementById('grid-container').innerHTML = undoStack[currentUndoSpotFromIndex];
  
  // light up current item in undo stack
  if (UNDO_VISUALIZER == true){
    let getLastUndoIndex = "board" + currentUndoSpotFromIndex;
    document.querySelectorAll(".board").forEach(
      function(board) {
        if (board.classList.contains(getLastUndoIndex)){
          board.style.border = "1px solid white"
        } else{
          board.style.border = "none";
        }
      }
    )
  }
  
  updateUndoButton(currentUndoSpotFromIndex);
  
  // re-set-up bindings 
  bindClicksForCurrentBoard();
}; 

 
 
 
//////// PXON STUFF 


function getCurrentPixels(){
  // get all current pixel elements (.dot class <div> items) and put them in an array
  var dots = document.querySelectorAll("#grid-container .dot");
  var currentBoard = [];
  dots.forEach(dot => 
    currentBoard.push(dot)
  );
  
  // slice that array at each row of pixels, calculated from board size.
  // each element in gridArray will be an array containing a row worth of
  // pixel elements. 
  for(i = 0; i < BOARD_SIZE; i++){
    if(i < 1){
      gridArray[i] = currentBoard.slice(0, BOARD_SIZE);
    }else{
      var oldVal = (i) * BOARD_SIZE;
      var newVal = (i + 1) * BOARD_SIZE;
      gridArray[i] = currentBoard.slice(oldVal, newVal);
    }

  }
  return gridArray;
}


function updatePXON(){
  createPXON();
  pxonClean = JSON.stringify(pxon, undefined, 3)
  document.getElementById("raw").innerHTML = pxonClean; 
} 

// Export PXON
function createPXON(){
  var gridArray = getCurrentPixels();
  pxon = {
    exif: {
      software: "ryanwhitney.github.io/dotter",
      artist: "YOUR NAME HERE!",
      imageDescription: "DESCRIBE THE THING",
      userComment: "AND COMMENT ON IT",
      copyright: "do your name again ©",
      dateTime: new Date()
    },
    pxif: {
      pixels: []
    }
  };
  
  // Get color from each x,y coordinate
  var defaultColor = inputInitialDotColor.value
  function getpixelColor(pxArray){
    var xyPixelColor = pxArray[x][y].style.getPropertyValue('--dotColor');
    if(xyPixelColor.length > 0){
      return xyPixelColor;
    }
    else{
      return defaultColor;
    }
  }
  // From getCurrentPixels() we have an array element that contains arrays of each row of pixels. This lets us grab XY coordinates. 
  var n = 0;
  for(x = 0; x < BOARD_SIZE; x++){
    for(y = 0; y < BOARD_SIZE; y++){            
        var pixel = new Object();  
        pixel.x = (y * pxonScale); // we can agree to not talk
        pixel.y = (x * pxonScale); // about this part ok
        pixel.size = pxonScale;
        pixel.color = getpixelColor(gridArray);
        pxon.pxif.pixels[n] = pixel;
        n++;
    }
  }  
  return pxon;
}
      
function paint(x,y,color){
  if( x.isNaN && y.isNaN ){
    console.log("both x and y coordinates need to be defined")
  } else{
    if(!color){
      color = newDrawColor;
    }
    updatePixel(gridArray[x][y],color);
  }
  return false;
}


function line(x1,y1,x2,y2,color){
  if( x1.isNaN && y1.isNaN && x2.isNaN && y2.isNaN ){
    console.log("all coordinates need to be defined")
  } else{
    
    if(!color){
      color = newDrawColor;
    }

    var diffX = x2-x1;
    var diffY = y2-y1;
    for(i = x1; i <= x2; i++){
        console.log("i: " + i);
        updatePixel(gridArray[i][y2],color);
    }
  }
}
      
      
      




// Render a PXON document to SVG
// https://github.com/pxon/pxon-schema

function render(pxon, container) {

  // Remove existing
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }

  const svgns = 'http://www.w3.org/2000/svg';
  const el = document.createElementNS (svgns, 'svg');
  el.setAttribute('xmlns', svgns);
  el.setAttribute('version', '1.1');
  el.style.width = '100%';
  el.style.height = '100%';

  const {
    pxif: { pixels }
  } = JSON.parse(pxon);

  pixels.forEach((p) => {
    const ps = p.size;
    const pc = p.color;

    // Normalise x/y values to closest grid coordinate
    const px = ps * Math.ceil(p.x/ps);
    const py = ps * Math.ceil(p.y/ps);

    const pixel = document.createElementNS(svgns, 'rect');
    pixel.setAttribute('x', px);
    pixel.setAttribute('y', py);
    pixel.setAttribute('width', ps);
    pixel.setAttribute('height', ps);
    pixel.setAttribute('fill', pc);

    el.appendChild(pixel);
  });

  container.appendChild(el);
}

function dunno(thiswasntinafunction){
  
  const input = document.getElementById('input');
  const output = document.createElement('div');
  output.setAttribute('id', 'output');
  document.body.appendChild(output);
  
  input.oninput = function(e) {
    render(input.value, output);
  }
  
  // Trigger initial render
  input.dispatchEvent(new Event('input'));
}


// DOWNLOAD!? thank u https://stackoverflow.com/a/30832210
function download(data, filename, type) {
  var file = new Blob([data], {type: type});
  if (window.navigator.msSaveOrOpenBlob) // IE10+
      window.navigator.msSaveOrOpenBlob(file, filename);
  else { // Others
      var a = document.createElement("a"),
              url = URL.createObjectURL(file);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function() {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);  
      }, 0); 
  }
}

    </script>
  </body>
</html>
